---

`HTTP`는 `RFC`에서 규정한 `프로토콜`이다. 현재 규정된 버전은 1.1 버전이다. HTTP는 `REST`의 중요 특징인 `uniform interface`, `stateless server` , `cache`등을 구현하고 있는 Web기반 프로토콜이다.

### TCP/IP

| 애플리케이션 계층

|HTTP, NTP, SSH, SMTP, DNS|
|---|
|트랜스포트 계층|
|UDP, TCP|
|인터넷 계층|
|IP|
|네트워크 인터페이스 계층|
|이더넷|

HTTP는 `TCP/IP` 기반이다. `TCP`(Transmission Control Protocol), `IP`(Internet Protocol)의 약자를 가진 TCP/IP는 인터넷 토대를 구성하는 네트워크 프로토콜이다.

**- 계층형 프로토콜** 인터넷 네트워크 프로토콜은 계층형 구조를 가지고 있다. 각 계층별 추상화 하여 구현을 하여 물리적으로 케이블이 동선인지 광케이블인지 하는 하위 계층의 사항에 영향을 받지 않고 상위 계층을 구현 할 수 있다.

네트워크 인터페이스 계층 네트워크 인터페이스 계층은 물리적인 케이블이나 네트워크 어댑터에 해당한다.

**- 인터넷 계층** 실제 네트워크에서 데이터를 주고받는 계층이다. TCP/IP의 IP가 해당된다. IP에서 기본 통신 단위를 패킷이라 한다. 지정한 IP 주소와 패킷 단위로 데이터를 주고받으며 통신한다.

**- 트랜스포트(전송) 계층** IP가 하지 않은 데이터 무결성을 보증하는 역할을 하며 TCP/IP의 TCP가 해당된다. TCP는 목적지의 상대에 대해 커넥션을 연결한다. 커넥션을 사용해 데이터 누락을 체크하고 데이터 도달을 보증한다. TCP접속된 커넥션에서 전송하는 데이터가 어느 애플리케이션으로 전달될지 결정하는 것이 포트번호이고 HTTP는 well-known 포트번호인 80을 사용한다.

**- 애플리케이션 계층** 구체적인 인터넷 애플리케이션, `메일`이나 `DNS`, `HTTP`를 실현하는 계층이다. TCP로 만들 때 `소켓`이라는 라이브러리를 주로 사용하며 소켓은 네트워크에서 데이터 교환을 추상화한 API로 접속, 송신, 수신, 절단 등의 기능을 갖추고있다. HTTP는 소켓을 이용해 구현한다.

## HTTP method

HTTP 1.1에서 method는 8개이다. `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS`, `TRACE`, `CONNECT`가 있다. 그중 대표적인 메서드는 `CRUD`를 구현하는데 필수인 메서드로 `GET`, `POST`, `PUT`, `DELETE`가 된다.

**- GET - 리소스 취득** `GET`은 지정한 URI의 정보를 가져온다. 이용빈도가 가장 높은 메서드로 웹 페이지, 이미지, 동영상 등 취득을 위해 사용한다.

**- POST - 리소스의 작성, 추가** `POST`의 대표 기능은 어떤 리소스에 대한 서브 리소스의 작성이다. 다른 기능으로는 기존의 리소스에 데이터를 추가 하는 것이다. 마지막으로 POST의 다른 기능은 다른 메서드로는 대응할 수 없는 처리의 실행이다. URI에 쿼리 키워드가 너무 길게 작성이 된 경우 URI의 길이는 2000등의 상한선이 존재 할 뿐 길이에 제한이 없지만 그런 긴 키워드의 경우 URI에 키워드를 넣어 GET하는 방식을 이용할 수 없다. 이런 경우 차라리 POST를 사용해 URI에 사용된 키워드를 request message의 body에 넣어 사용한다.

**- PUT - 리소스의 갱신, 작성** `PUT`의 첫 번째 기능은 리소스의 갱신이다. 어떤 리소스 데이터가 ‘a’인 경우 ‘b’로 갱신을 희망할 때 사용한다. 두번째는 리소스의 작성이다. 특정 URI에 리소스가 아직 존재하지 않는 경우 PUT은 존재하지 않는 URI에 대한 요청이기 때문에 리소스를 새로 작성한다고 해석해 요청이 성공한 경우 201 created를 반환한다. 만약 해당 URI에 리소스가 있는경우는 리소스를 갱신하는 처리를 한다. 하지만 이런 리소스를 추가하는 메서드는 위에서 POST를 사용한다. 어떻게 이 두개의 메서드를 구분할까? POST로 리소스를 작성하면 클라이언트는 리소스의 URI를 지정할 수 없다. 즉, URI의 결정권이 서버에 있다. 반면 PUT 메서드로 리소스를 작성하면 리소스의 URI는 클라이언트가 결정하게 된다. 일반적으로 클라이언트가 리소스의 URI를 결정할 수 있다는 것은 클라이언트를 만드는 프로그래머가 서버의 내부구현(URI에 어누 문자를 허용할지, 길이의 제한은 어느정도인지 등)을 숙지 해야한다. 그 때문에 PUT은 서버와의 결합이 밀접하다. 특별한 이유가 없는 한 리소스 작성은 POST로 수행하여 URI를 서버측에서 결정하는 설계가 이상적이다.

**- DELETE - 리소스 삭제** `DELETE`는 말 그대로 리소스를 삭제한다. 일반적으로 DELETE의 응답은 바디를 가지지 않는다.

### 멱등성 과 안전성

통신 에러가 발생할 때 요청을 어떻게 회복할지는 HTTP 프로토콜에 있어 중요하다. HTTP에서 stateless를 유지하면서 이 문제를 해결하기 위한 아이디어가 도입되어 있다. `멱등성`이란 ***“어떤 조작을 몇 번을 반복해도 결과가 동일한 것”***이란 수학적 용어이다. 예로 어떠한 실수에 0을 곱하면 결과는 0이다. 즉, 0의 곱셈은 멱등이다. 그리고 안전이란 “조작 대상의 리소스 상태를 변화시키지 않는 것”이다. 리소스의 상태 변화를 프로그래밍에서느 side effect(부작용)이라 하는데 결론적으로 `안전`은 ***“조작대상인 리소스에 부작용이 없는 것”***이다.

|메서드|성질|
|---|---|
|GET, HEAD|멱등, 안전하다|
|PUT, DELETE|멱등이지만 안전하지 않다|
|POST|멱등이지도 안전하지도 않다|

**- PUT 멱등** 어떤 리소스를 GET하고 PUT으로 test1을 test2로 갱신한다 할 때 PUT요청이 성공하면 test2로 변경된다. 하지만 에러가 발생해 클라이언트가 응답을 확인 못하면 다시 같은 요청을 할 수 있고 200OK를 받으면 PUT 메서드로 두번의 통신을 했지만 결과는 한 번 송신할 때와 같다.

**- DELETE 멱등** 어떤 리소스를 삭제하고 200 OK가 반환 되었을 떄 다시 같은 요청을 하면 404 Not Found가 리턴될 것이다. 하지만 리소스가 삭제되었다는 결과는 전과 동일하기에 멱등하다.

**- GET, HEAD 멱등 + 안전** 어떤 리소스를 몇번을 GET하여도 결과는 바뀌지 않으며 그 리소스의 시점에서 표현을 가져올 수 있다. 그리고 PUT, DELETE는 리소스의 상태를 변화시키지만 GET, HEAD는 리소스의 상태도 변화 시키지 않는 안전이란 성질 또한 가진다.

**- POST 멱등x + 안전x** POST는 멱등하지도 안전하지도 않다. 요청 결과로 어떤 일이 벌어질지 모른다. 클라이언트는 그렇기에 POST를 여러번 요청하는 것에 신중해야한다.

### 웹의 성공의 이유

HTTP에서는 위에서 보듯 아주 적은 수의 method만 정의하고 사용한다. 이것이 `REST`의 `통일 인터페이스 제약`이다. 메서드를 한정하여 고정시켰기 때문에 결국 프로톨이 심플하게 유지되었고 이로 인해 웹이 성공했다. 그리고 GET에 숨겨진 안정성, PUT, DELETE의 멱등성, 뭐든 가능한 POST의 메서드 들은 HTTP는 각각의 메서드에 맞는 성질과 확장성을 가지게 해준 프로토콜이다.

## 스테이터스 코드

흔히 웹 기술을 잘 모르는 사람도 404나 500과 같은 숫자로 Not Found, Internal Server Error와 같은 문자열이 출력되는 화면을 본 경험들이 있다. 이렇게 HTTP의 status code는 친숙한 숫자로 표현된다. HTTP 1.1의 스테이터스 코드는 `RFC2616`에 정의된다.

**- 1xx: 처리중** 계속 `처리중`이란 뜻이다. 클라이언트는 요청을 계속하던지 서버의 지시에 따라 프로토콜을 업데이트 하여 재전송한다.

**- 2xx: 성공** 요청이 `성공`함을 의미

**- 3xx: 리다이렉트** 다른 리소스로의 `리다이렉트`를 의미한다. 클라이언트는 이 스테이터스를 받을 때 response message에서 `Location`헤더를 보고 새 리소스에 접속한다.

**- 4xx: 클라이언트 에러** `클라이언트` 요청에 문제가 있어 발생한다. 문제를 해결하지 못하면 정상적인 결과를 얻을 수 없기에 같은 요청을 재전송할 순 없다.

**- 5xx: 서버 에러** 에러의 원인이 `서버`에 있다. 서버측 원인이 해결되면 동일한 요청을 재전송해 정상적인 결과를 얻을 수 있다.

## HTTP 헤더

헤더는 메세지의 바디에 대한 부가적인 정보, 즉, `메타 데이터`를 표현한다. 클라이언트와 서버는 헤더를 보고 메세지에 대한 동작을 결정한다. 또한, 리소스에 대한 접근 권한을 설정하는 인증이나 클라이언트와 서버의 통신 횟수를 줄이기 위한 캐시같은 HTTP 기능을 헤더로 표현하기도 합니다.

### MIME 미디어 타입

메세지로 주고받는 리소스 표현의 종류를 지정하는 것이 `MIME` 미디어 타입이다. `Mutipurpose Internet Mail Extensions`의 이름 같이 전자메일에서 차용해온 스펙이다. MIME은 복수의 메일 헤더를 정의하지만 HTTP에서는 그중 `Content-Type`헤더 등 몇개만 이용한다. MIME 미디어타입을 우린 미디어 타입이라고 줄여서 말하기도 한다.

**- Content-Type - 미디어 타입을 지정하다** `Content-Type` 헤더는 그 메세지의 바디 내용이 어떤 종류인지 정의한다. 예로 application/xhtml+xml을 들면 ‘/’ 왼편을 타입이라 부르고 오른편을 서브타입이라 부른다. 즉, application이 타입 xhtml+xml을 서브타입이라 한다.

**- charset 파라미터 - 문자 인코딩 지정** 미디어 타입은 `charset` 파라미터를 가질 수 있다. 앞의 XHTML에서 `charset utf-8`로 이 XHTML문서를 `UTF-8`로 인코딩하고있다는 뜻이다. charset 파라미터는 생략이 가능하지만 타입이 text인 경우 주의해야한다. HTTP에서 text타입의 디폴트 인코딩은 ISO 8859-1인데 메세지에 한글이 들어 있음에도 불구하고 클라이언트가 잘못된 디폴트 인코딩 방식을 사용해 문자가 깨질 수 있다. 그리고 XML에서 문서 자체에 문자 인코딩 방식을 선언할 수 있어도 text타입은 `Content-Type`의 `charset``파라미터를 우선한다.

### 언어 태그

`charset` 파라미터는 문자 인코딩 방식을 지정하는 것이지만 리소스 표현의 자연언어를 지정하는 헤더도 있다. `Content-Language`이다. 이 헤더의 값은 언어 태그라고 불리는 문자열이고 `RFC4646`에 정의되어있다.

### 콘텐트 네고시에이션

위의 내용인 미디어타입, 문자 인코딩, 언어 태그는 서버가 일방적으로 결정하는 것뿐 아니라 클라이언트와 교섭해 정할 수 있다. 이 방법을 콘텐트 네고시에이션이라 한다.

### Content-Length, Chunk 전송

**- Content-Length - 바디의 길이를 지정** 메세지가 바디를 가지고 있으면 기본적으로 Content-Length 헤더를 이용해 사이즈를 10진수 바이트로 나타낸다.

**- 청크 전송 - 바디를 분할하여 전송** 동적으로 이미지를 생성하는 웹 서비스의 경우 파일 사이즈가 정해질 때 까지 응답할 수 없기 때문에 응답 성능이 저하된다. 이 때 사용하는 것이 Transfer-Encoding이다. `Transfer-Encoding: chunked` 를 예로 들면 Transfer-Encoding헤더에 chunked를 지정해 최종적으로 사이즈를 모르는 바디를 조금씩 전송이 가능하다.

### 인증

HTTP인증 방식에는 HTTP 1.1이 규정하는 `Basic` 이증과 `Digest` 인증이 있다. `WWW-Authenticate`헤더를 통해 클라이언트는 서버가 제공하는 인증 방식을 이해할 수 있고 그방식에 따른 형식으로 인증 정보를 보낼 수 있다.

```jsx
HTTP/1.1 401 Unathorized
WWW-Autehnticate: Basic realm="~.com"
```

위 예는 서버가 Basic인증을 지원하고있음을 알 수 있다. 그리고 `realm`은 서버 상에서 이 리소스가 속한 URI 공간 이름이다.

BASIC 인증 이 인증은 유저의 이름과 패스워드에 의한 인증 방식이다. 유저의 이름과 패스워드는 `Authorization` 헤더에 넣어 요청마다 전송한다. 이 헤더의 내용은 인증 방식에 있어 유저 이름과 패스워드를 :로 연결하고 Base64 인코딩으로 한 문자열이다. 하지만 이 Base64 인코딩은 간단히 디코딩이 가능하단 점이다. Basic인증은 그렇기에 사용할 때 그것이 허용 될 정도로 보안이 좋은지, SSL와 TLS를 사용해 HTTPS 통신을 하고 통신선로 상에서 암호화 할 것인지를 검토해야 한다.

Digest 인증 Digest 인증은 Basic 인증보다 보안이 강화된 인증 방식이다. 이 인증 방식은 어떤 메세지에 대해 해시함수를 적용해 해시값을 말한다. Digest 인증은 Basic인증보다 복잡한 흐름으로 인증을 수행한다.

### 캐시

`캐시`란 서버로부터 가져온 리소스를 로컬 스토리지에 저장해 재사용하는 방법을 말한다. 로컬 스토리지에 캐싱한 데이터 자체를 캐시라고 부르기도 한다. 클라이언트가 지정한 캐시는 그 캐시의 유효 기간 내에 다시 그 리소스에 접근하려 할 때 재사용된다. 클라이언트는 서버에서 가져온 리소스의 캐시 가능 여부를 조사하고 가능한 경우 로컬 스토리지에 저장한다. 이때 어떤 리소스가 캐시 가능한지는 그 리소스를 취득 당시 헤더를 보고 결정한다. `Pragma`, `Expire`, `Cache-Control`헤더를 이용한다.

**- Pragma - 캐시를 억제한다.** `Pragma: no-chace` 프라그마 헤더에 지정할 수 있는 값은 공식적으로 `no-cache`뿐이다. 이는 값을 캐시하지 말란 뜻이다. 그렇기에 클라이언트에서 다음에 해당 리소스를 받을 때 반드시 다시 서버에 접속해야한다.

**- Expires - 캐시의 유효기간** `Pragma`가 억제였다면 `Expires`는 캐시의 유효기간을 나타낸다. 유효기간 기간에 따라 서버에 다시 접속할지 말지를 결정한다.

**- Cache-Control - 상세한 캐시 방법을 지정한다.** `Pragma`, `Expires`헤더는 `HTTP 1.0`에서 정한 헤더다. 간단한 캐시는 구현이 가능하다 복잡한 지정은 할 수 없다. Pragma헤더와 Expires헤더의 기능은 `Cache-Control` 헤더로 대체가능하다.

---

# HTTP vs HTTPS

위에서 말한 `HTTP`와 `HTTPS`차이를 자세히 보겠다.

### HTTP

기본적으로 HTTP는 웹 서버와 웹 클라이언트인 브라우저 간의 데이터 통신을 정의하는 프로토콜이다. `Request`와 `Response` 모델을 따르고 `TCP포트` 80번을 사용합니다. 이 프로토콜은 데이터를 `평문`으로 전송하기 때문에 중간에 패킷을 누군가 가로채면 내용을 그대로 읽어 도청이나 변조가 가능하단 위험이 있다.

### HTTPS

HTTP의 `보안` 버전이다. 데이터를 안전하게 전송하는 프로토콜이다. `SSL(Secure Sockets Layer)`또는 `TLS(Transport Layer Security)` 프로토콜을 사용하여 데이터를 암호화 합니다. TCP 443포트번호를 사용하고 클라이언트와 서버간의 통신을 보호한다.

### HTTP vs HTTPS

크게 3가지의 차이가 있습니다. `보안성`, `포트번호`, `SSL/TLS 핸드셰이크`

**- 보안성** HTTPS는 평문으로 전송하니 패킷을 가로채 내용을 읽을 수있다. 하지만 HTTPS는 SSL/TLS로 데이터가 암호화되어 패킷을 가로채더라도 내용을 해독하기 어렵다. 그렇기에 데이터의 기밀성, 무결성, 서버 인증을 제공합니다.

**- 포트번호** HTTP는 80, HTTPS 443을 사용합니다.

**- SSL/TLS 핸드셰이크** HTTP는 SSL/TLS 핸드셰이크 과정이 없다. HTTPS는 클라이언트와 서버간 SSL/TLS 핸드셰이크를 통해 인증서를 교환하고 대칭키를 설정해 데이터를 암호화 할 수 있습니다.

그렇기에 실무에서도 HTTP에서 민감한 데이터를 다루면 피싱, 중간자 공격, 데이터 스니핑 등의 위험이 있고 HTTPS로 이런 공격을 방지하고 로그인, 결제, 개인정보를 안전히 보호 해야한다. 또한 구글 검색엔진에서 SEO를 HTTPS에 가중치를 두기에 HTTPS 사용을 해야한다.

### SSL, TLS, 핸드셰이크 과정

SSL ( Secure Sockets Layer ) `SSL`은 네트워크 통신의 보안을 위해 넷스케이프에서 개발된 프로토콜이다. 데이터 전송시 기밀성, 무결성, 인증을 제공하여 중간자 공격과 도청으로 부터 데이터를 보호한다.

TLS ( Transport Layer Security ) `TLS`는 `SSL`의 후속 버전으로 보안과 성능이 개선되었다. SSL과 동일한 보안을 제공하지만 추가적인 보안과 성능 향상이 되었으며 SSL에 비해 암호화 및 알고리즘이 더욱 개선되었다.

### 핸드셰이크 과정 → 클라이언트와 서버가 서로를 인증, 세션 키를 교환하여 통신을 암호화 하는 과정

1. **클라이언트 헬로(Client Hello)**: 클라이언트가 서버에게 지원하는 프로토콜 버전, 암호화 방법, 난수 등을 전송합니다.
2. **서버 헬로(Server Hello)**: 서버가 선택한 암호화 방법, 인증서, 세션 ID, 난수 등을 클라이언트에게 전송합니다.
3. **서버 인증**: 서버는 자신의 인증서를 클라이언트에게 보내고, 클라이언트는 이를 검증합니다.
4. **키 교환**: 클라이언트와 서버는 세션 키를 교환하여 데이터 암호화에 사용할 대칭키를 설정합니다.
5. **완료 메시지**: 핸드셰이크가 완료되었음을 알리는 메시지를 주고받고, 이후의 데이터는 암호화되어 전송됩니다.