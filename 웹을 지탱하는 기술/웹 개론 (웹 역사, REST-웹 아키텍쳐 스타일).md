### 다양한 웹의 용도

현재 우리 생활에 깊숙히 영향을 주고있는 `웹`은 구체적으로 어떻게 사용될까? 웹의 용도를 3가지로 나눠 설명하겠다.

**웹 사이트** 네이버, 아마존, 구글등 다양한 서비스를 제공하는 웹 사이트가 있다. 웹 사이트 시스템 구성은 PC베이스의 UNIX서버 1대인 경우 부터 수 천, 수 만대의 서버를 조합한 대규모 까지 다양하다. 하지만 웹 사이트 내부가 어떤 구성을 하고 있는지 클라이언트가 의식하지 않아도 되는 점은 웹의 공통적인 특성이다.

**유저 인터페이스로서 웹** 웹 기술은 유저 인터페이스 분야에도 사용되고 있다. 라우터, TV, 프린터 등 네트워크에 접속이 필요한 디바이스 설정 화면이 `브라우저`로 이루어지는 것이 적지 않다. 이유는 리모컨과 같은 버튼으로 설정하는 것 보다 PC키보드로 조작하는 편이 효율적이기 때문이다.

**프로그램을 위한 API로서 웹** 유저 인터페이스 웹이 유저 중심의 인터페이스지만 `API`로서 웹은 프로그램 중심이다. API는 데이터 포맷으론 `XML`, `JSON`과 같이 프로그램에서 해석하고 처리하기 쉬운 것을 이용한다. API로서 웹을 `웹 서비스`라고 부른다.

## 웹의 역사

### 웹 이전의 하이퍼미디어

**- Memex - 하이퍼미디어 기원** 하이퍼미디어 기원은 ARPANET보다 더 올라가 1945년 미국 연구자 버니바 부시가 발표한 Memex라는 정보 검색 시스템 논문이다. 실제로 존재했던 시스템은 아니지만 전기적으로 접속한 책과 파일을 서로 링크하고 링크를 따라 표시하는 현재 웹을 예상할 수 있는 시스템이였다.

**- Xanadu - 하이퍼미디어 단어의 탄생** Memex에 영향을 받은 넬슨이 1965년 하이퍼 텍스트와 하이퍼미디어라는 말을 고안했다. 하이퍼텍스트가 문자 정보 중심의 문서를 상호 링크 시키는 개념, 하이퍼미디어는 그 사고를 확장해 음성과 동영상 다양한 미디어를 상호 링크 시킨 개념이다. 그러나 Xanadu개발은 고기능으로 인한 복잡성으로 실패하였다.

**- HyperCard - 최초의 실용적인 하이퍼미디어** 웹 이전 성공한 하이퍼미디어는 애플에서 개발한 하이퍼카드이다. 이는 네트워크를 통해 데이터를 주고 받는 기능이 없고 문서를 단위로 상호 링크하고 스크립트 언어인 HyperTalk에 의한 프로그램을 실행할 수 있는 stand-alone 방식의 웹서비스였고 이 하이퍼카드는 성공을 거두어 많은 게임과 애플리케이션이 개발되었다.

**- 웹 이전의 하이퍼미디어의 문제점** 지금 까지 가장 성공적으로 보급된 하이퍼미디어는 웹입니다. 이 웹의 리소스는 모두 링크에 의해 연결되어있습니다. `웹`이 성공이 가능했던 이유는 최소한의 링크 기능만 갖추고 있었다는 점이며 웹 이전의 하이퍼미디어의 최대 문제는 `복잡성`에 있습니다.

### 웹의 탄생

웹은 1980년대 까지 `하이퍼미디어`에 대한 구상이 생겨나고 인터넷이 등장하면서 복수의 컴퓨터를 연결한 `분산 시스템`이 구축되었다. 웹은 이런 시대적 환경에서 탄생하였다.

웹은 `팀 버너스리`라는 사람이 하이퍼미디어를 이용한 인터넷 기반의 분산정보관리 시스템이라는 제안서를 작성하면서 구현되기 시작되었다. 이러한 웹의 보급을 앞당긴건 일리노이 대학의 NCSA가 공개한 브라우저 `Mosaic`이다.

웹은 `개방형`이고 불특정 다수를 상대로 하는 시스템이다. 유저의 컴퓨터 환경은 특정한 OS와 하드웨어로 통일되지 않았으며 다양한 브라우저와 디바이스를 통해 하나의 웹서비스에 접근할 수 있다. 이것은 클라이언트와 서버 간의 인터페이스를 HTTP라는 심플한 프로토콜로 고정함으로 실현되었다.

### 웹의 표준화

Mosaic에 의해 폭발적으로 웹이 보급됨에 따라 웹을 구성하는 기술에 대한 표준화가 요구되었다. 특히 `HTTP`, `URI`, `HTML`이 그 기술이다. 이 `표준화`를 담당하는 기관이 우리가 많이 들었던 `IETF`이며 `RFC`로 정해왔다. 하지만 이 때 너무 빠른 웹의 보급으로인해 웹 기술을 구현하고 있는 벤더들이 모여 표준화를 수행하는 단체인 `W3C`를 설립한다.

### REST의 탄생

캘리포니아의 대학원생인 `필딩`이란 사람이 등장한다. 그는 HTTP1.0, HTTP1.1스펙을 정하는데 관여하였다. 그는 웹이 어떻게 성공하였는지, 왜 이정도의 대규모 시스템이 성립된건지에 대해 소프트웨어 아키텍처 관점에 분석하였고 하나의 아키텍쳐 스타일로 정의하였다. 우리는 이 아키텍쳐 스타일을 `REST`라 부른다.

### 웹 API를 둘러싼 논의

1990년 후반 웹이 상업적인 성공을 거두고 버블이 맞이한다. 이때 HTTP 1.1을 책정하는 필딩의 그룹과 별개로 가장 큰 세력을 가진 RPC/분산 오브젝트 그룹이 있다 이들은 분산 오브젝트로 자사의 기술을 스탠더드로 만들기 위해 표준화 경쟁을 벌였다. 이들의 프로토콜은 `SOAP`입니다. `SOAP`는 `HTTP`를 애플리케이션 프로토콜이 아닌 트랜스포트 프로토콜로 다루고, HTTP 상에서 독자적으로 메시지를 전송합니다. `SOAP`는 메시지 전송 방법만 규정한 스펙이기에 `SOAP`상에 서비스 별로 프로토콜을 정의해야했다. 하지만 이경우 페이지 수가 급증하게 되면 구현이 어려워진다는 비판을 받았다.

**- SOAP vs REST** `필딩`은 이런 `SOAP`의 기술을 부정하고 _**웹이 웹다울 수 있는 아키텍쳐로 REST**_를 권장하였다. 하지만 개인과 대기업의 정치적 파워로 인해 SOAP 스펙 책정 작업이 W3C에서 계속 진행되었다.

2000년대부터 SOAP와 REST의 논쟁은 계속되었고 구글이 검색엔진으로서 위치를 가질 때 현재와 같은 프로그램으로 웹을 조작 가능한 웹 API는 존재하지 않았다. REST가 보급되기 시작한건 아마존 웹 서비스였다. 이들은 보인의 웹 서비스를 SOAP를 이용한 형식과 REST형식 2가지를 준비했다. 이 때 SOAP와 REST 사용 비율은 20대 80이였다는 보고를 한다.

이 때 REST를 부정하는 사람은 아마존 처럼 보안이 필요없는 간단한 웹 API에서 URI를 GET하는 단순한 방식이 어떻게 기간 시스템 같은 트랜잭션과 신뢰성이 필요한 곳에서는 사용을 못한다 하였다. 하지만 결국 REST 측이 승리하였고 구글과 아마존 같은 기업들이 REST형식으로 웹 API를 제공하기 시작했다.

## REST - 웹 아키텍쳐 스타일

### 아키텍쳐 스타일의 중요성

`REST`는 웹의 아키텍쳐 스타일이다. 아키텍처 스타일은 복수의 아키텍처의 공통된 성질, 양식 규정을 일으키는 말이며 `아키텍쳐 패턴`이라고도 한다. 이런 아키텍처 스타일에는 `MVC`, `파이프 앤 필터`, `이벤트 시스템` 등이 있다. 여기서 패턴을 듣고 디자인 패턴을 생각 할 수 있으나 디자인 패턴은 `마이크로 아키텍처 패턴`이라고 하며 아키텍처 스타일보다 입도가 작은 설계 양식을 가진다. 실제 시스템은 구체적인 아키텍처를 가지고 있다. 이때 아키텍처의 설계 지침, 방식 즉, 아키텍처 스타일을 적용하고 시스템의 아키텍처를 결정할 때 나침반이 되는게 아키텍처 스타일이다.

### 아키텍처 스타일에서 REST

REST는 네트워크 시스템의 아키텍처이다. 네트워크 시스템의 가장 유명한 아키텍처 스타일은 클라이언트-서버이다. 그리고 웹은 클라이언트-서버이다. 결론적으로 웹은 REST이기도 하지만 클라이언트-서버이다. 혼란스럽지만 REST는 클라이언트-서버 구조에서 몇가지 제약을 더해 탄생한 아키텍처 스타일이다.

여기서 아키텍처 스타일은 특정한 구현이나 아키텍처가 아니다. 구현에서 추상도를 올린게 아키텍처 그리고 아키텍처에서 한 단계 더 추상도를 올린게 아키텍처 스타일이다.

|추상화 레벨|웹에서의 예|
|---|---|
|아키텍처 스타일|REST|
|아키텍처|브라우저, 프록시, 서버, HTTP, URI, HTML|
|구현|Apache, FireFox, Internet Explorer|

### 스타일을 조합해 REST를 구성한다

RESTful한 설계를 하기 위해 아래의 조건을 따라야한다.

- 클라이언트-서버
- 스테이트리스 서버
- 캐시
- 유니폼 인터페이스
- 계층화 시스템
- 코드 온 디맨드

지금부터 이 6가지를 통해 REST 구성에 대해 알아보자

**1. 클라이언트-서버** 웹은 HTTP라는 프로토콜을 이용해 클라이언트와 서버가 서로 통신하는 `클라이언트-서버` 아키텍처 스타일을 사용한다. 클라이언트가 서버에 `Request`를 보내면 서버는 클라이언트에 `Response`를 돌려준다. 이로 인해 단일 컴퓨터 상에서 모두 처리하는게 아닌 클라이언트와 서버로 분리해 처리가 가능하기에 클라이언트를 멀티 플랫폼으로 구성할 수 있다. 또한, UI는 클라이언트에서 담당하기에 서버는 데이터 스토리지로서 기능만 제공하면 되고 복수의 서버를 조합해 확장함으로 가용성을 높힐 수 있다.

**2. Stateless Server** 클라이언트의 상태를 서버에서 관리하지 않는다는 의미다. 서버가 애플리케이션의 상태를 가지지 않게 됨으로 서버측의 구현을 간소화 할 수 있다. 하지만 `쿠키`는 stateless가 아닌 `stateful`하게 동작한다. 필자도 세션 인증을 구현할 때 쿠키를 사용했지만 적어도 쿠키를 사용할 땐 `REST`의 관점에서는 잘못된 확장이란 개념을 가지고 사용해야 한다.

**3. 캐시** 리소스의 `신선도`에 기초해 한번 가져온 리소스를 클라이언트에서 돌려쓰는 방식이다. 이는 클라이언트와 서버 사이 통신양을 줄여 처리 시간을 축소하고 효율적인 관리가 가능하지만 오래된 캐시를 이용하면 정보의 신뢰성이 떨어질 수 있다.

**4. 유니폼 인터페이스** 유니폼 인터페이스는 URI로 지정한 리소스 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일이다. 흔히 우리가 GET, POST등 8개의 메서드만 사용하고 확장할 수 없다는 점을 생각하면된다. 이렇게 인터페이스 유연성에 제약을 둠으로 전체적인 아키텍처가 간결해진다. 그리고 `유니폼 인터페이스`야 말로 `REST`를 대표하는 아키텍처 스타일이다.

**5. 계층화 시스템** 위의 유니폼 인터페이스로 인해 시스템 전체를 `계층화` 하기 쉽다. 웹 서비스는 서버와 클라이언트 간 로드 밸런서를 설치해 부하를 분산시키고, 프록시를 설치해 액세스를 제어한다. 클라이언트는 프록시나 서버나 같은 인터페이스로 접속이 가능하기에 접속할 곳이 서버에서 프록시로 변경된 것을 신경 쓸 필요가 없다. 이와 같이 시스템을 몇개의 계층으로 분리하는 아키텍처 스타일을 계층화 시스템이라 한다.

**6. 코드 온 디맨드** 프로그램 코드를 서버에서 다운 받아 클라이언트에서 실행하는 아키텍처 스타일이다. 흔히 우리가 사용하는 `javaScript`가 예시이다. 코드 온 디맨드의 장점은 클라이언트를 확장할 수 있다는 점이다. 클라이언트 프로그램에 이미 준비된 기능 뿐 아닌 새로운 기능을 추가할 수 있다.

### REST의 의미

결론적으로 `REST`는 웹 전체의 아키텍처 스타일이다. 웹은 `REST`라는 `분산 네트워크 시스템`을 위한 이론이 있었기에 이렇게 성공했다. 물론 개발을 하면서 `RESTful`한 조건을 모두 충족하며 개발하긴 쉽지 않다. 예로 `쿠키` 정보를 통해 세션값에 저장을 하거나 하면 `stateless server`라는 REST 조건은 무시되지만 URI 형식은 REST를 따르는 아키텍처를 생각할 수 있다. 말 그대로 설계 작업이니 어느정도 아키텍처의 이상과 타협이 필요한 부분도 있다. 하지만 REST를 이해하고 웹 API를 `RESTful`하게 설계하려 하면 더 좋은 웹이 될 것이다.