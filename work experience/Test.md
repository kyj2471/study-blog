
# 자기소개

### Q) 1px 오차도 용납하지 않는다 하셨는데 어떤 경험이 있었나요?

- 답변
    
    개발을 하고 QA를 진행하면서 초기에 디자인관련 피드백사항이 너무 많아 개발자와 디자이너의 리소스가 너무 많이 소모되었습니다. 이런 문제를 해결하기위해 공통된 UI를 분리하고 타이포그래피를 정의하는 등 디자인 시스템을 도입하였습니다. 당시 디자인 시스템 도입만으로 50% 이상의 디자인 피드백 사항이 줄었던 경험이 있습니다. 하지만 규모가 작은 스타트업에서 여러 플랫폼을 봐야하는 디자이너의 리소스는 한정되어 있어 애초에 QA 피드백 사항이 전혀 없길 원했습니다. 그렇기에 디자이너에게 어떤식으로 QA를 진행하는지를 확인 결과 개발된 화면과 디자인 가이드를 서로 대조하여 1px단위의 오차를 디자이너가 찾아내는것을 확인하였습니다. 그래서 다음 작업부터 UI작업시 컴퍼넌트별 직접 확인하면서 작업을 하였고 실제 QA를 진행하기전 자체적으로 전체적으로 개발된 화면과 디자인 가이드를 비교하였습니다. 그리고 이렇게 작업 한 결과 1px오차 없이 한 분기동안 디자인 피드백 사항이 없었던 경험이 있었고 1px오차 없이 개발했던 경험은 제가 아닌 주변에서 그렇게 불러주셔서 이력서에 추가하게 되었습니다.
    

### Q) 조직 발전에 도움을 주셨다고 했는데 어떤 일을 하셨나요?

- 답변
    
    아래 상세 경력에 적어 놓은 내용들로 서비스 전반의 컨벤션 정립 및 최적화, 기술 스택 최신화등의 기여를 하였습니다. 그리고 개발 외적으로 OKR업무 방식을 통해 물론 실패했던 피쳐도 있었지만 회사 서비스를 이용하는 회원수 및 판매 중인 상품수를 대폭 증가 시켰던 경험이 있었습니다.
    

### Q) OKR 업무 방식으로 어떤 기획에 참여하였고 성과는 어떠셨나요?

- 답변
    
    가장 기억에 남는 업무로 실패했던 경험이 있습니다. 초기 OKR 업무 방식에 대한 이해도가 낮아서 발생했던 일인데 기존에 유저들의 사용률이 적었던 관심이란 탭이 있었으나 해당 탭을 리뉴얼하여 본인이 팔로우하는 회원들의 상품들을 노출시키도록 대규모 변경을 하였던 경험이 있었습니다. 하지만 OKR 업무 방식은 우리의 목표를 달성하기위해 목표 외적인 일은 어느정도 생각 하지 말았어야 했는데 단순 개발자로서 보이는 업무를 진행했습니다. 결과적으로 투입된 시간과 리소스 대비 좋은 결과를 얻지 못했습니다. 그 뒤로 OKR 방식에 맞는 일을 하도록 노력을 했고 결론적으로 대량 판매자 N명 이상 이였던 Objective를 달성하는데 기여하였습니다.
    

### Q) 스터디는 어떻게 계속 해오셨나요?

- 답변
    
    개발을 처음 시작할 때 부터 함꼐 공부하던 크루가있었습니다. 주말에 특별한 일이 없으면 지금도 계속 만나면서 개발 관련된 이야기를 계속합니다. 저는 이 사람들을 계속만나면서 react-query에 대한 이야기를 하면서 저도 관심이 생겨서 당일 집에 귀가해서 해당 공식문서와 간단한 youtube에서 활용사례를 확인하고 회사 프로젝트에서도 필요하다 생각이 들어서 도입했던 경험이 있습니다.
    

### Q) 운동 계속 해요…? (이딴걸 물어볼까?)

- 답변
    
    네 저는 회사를 다니면서 많은 일이 있어도 스트레스가 거의 없었던것 같습니다. 그 이유로 제가 시간만 나면 운동을 하러가서 그런 것 같습니다. 운동 보다 먹는걸 좋아해서 살이 좀 쪄있긴하지만…ㅎ 헬스장가서 근력운동하는걸 주로 하고 테니스, 골프, 크로스핏 등 여러 운동을 즐겨 합니다.
    

# 상세 경력

### Q) UI 컴포넌트 개발 업무 생산성 개선

- 당신의 이력서에 따르면 디자인 시스템을 도입했다고 언급하셨습니다. 디자인 시스템 도입의 필요성을 느끼게 된 계기는 무엇이었나요?
    
    초기 회사에 입사 당시에 저희는 디자인시스템관련하여 개발자와 디자이너간의 프로토콜이 없었고 디자이너도 없었습니다. 추후 디자이너를 채용후 협업을 하면서 디자인시스템이 없이 작업을 하다보니 UI개발 업무중 디자인 가이드에서 놓치는 부분이 있었고 이런 내용이 추후 개발이 완료된 이후 QA기간에 디자인 피드백사항이 많이 발생하여 QA에 소모되는 시간낭비가 있었습니다. 또한, 회사에서 리브랜딩을 진행하면서 디자인 시스템이 있었다면 간단하게 처리가 되었어할 문제였지만 기술 부채로 인해 방대한양의 스타일코드 수정이 필요한 상황이 있었습니다. 저희는 이런 문제를 해결하기위해 디자인 시스템 도입을 결정하였습니다.
    
- 디자인 시스템을 도입하기로 결정한 후, 구체적으로 어떤 과정을 통해 디자인 시스템을 구축했는지 설명해주시겠어요? 특히, 개발자와 디자이너 간의 협업 과정에서 겪은 어려움이나 해결한 방안이 있었는지 궁금합니다.
    
    초기에 디자이너는 타이포그래피, 모달, Alert, 버튼 등 디자인시스템에 관련된 전반적인 내용을 전체적으로 도입하길 희망하였습니다. 하지만 진행되면서 매일 위의 UI 디자인 가이드가 계속 변경되고 추가되며 일을 여러번 하게되는 문제가 있었습니다. 이러한 문제를 해결하기위해 먼저 타이포그래피를 도입하고 추후 하나씩 순차적으로 도입하는 방향으로 의견을 수립하였습니다. 결론적으로 비교적 변경되어도 간단하게 수정할 수 있는 타이포그래피를 우선적으로 도입하고 모달, Alert창등의 반복적으로 사용되는 UI는 어느정도 디자이너 팀에서 안정되었을 때 추가적으로 도입하였습니다.
    
- 타이포그래피부터 디자인 시스템을 도입하기 시작했다고 하셨는데, 타이포그래피 도입 과정에서 가장 큰 기술적 도전이나 문제는 무엇이었고, 이를 어떻게 해결했는지 구체적으로 설명해주시겠어요?
    
    가장 먼저 여러 레퍼런스를 확인 하면서 저희 서비스에서 편하게 사용할 수 있는 방법을 고민하였습니다. 초기에는 switch-case문으로 타이포그래피를 조합이 가능하도록 선언 후 태그에서 size, weight와 같은 속성을 props로 전달하면서 처리를 하였습니다. 하지만 단순 규약된 글꼴과 서체인 타이포그래피에서 규칙된 타이포그래피 보다 더 많은 타이포그래피를 조합을통해 만들어 질 수 있다는 점에서 실패하였습니다. 그후 각각의 타이포그래피를 각각의 객체에 선언하여 위의 문제를 해결하였지만 해당 타이포그래피를 실제 UI컴포넌트에서 사용하는 경우 태그 네이밍이 타이포그래피가 되며 전반적으로 UI컴포넌트의 가독성과 유지보수성이 낮아지는 문제가 있었으며 모바일웹인 경우 처리에도 문제가 있어 실패하였습니다. 최종적으로 타이포그래피를 단순 리터럴 객체로 전체를 선언하고 해당 데이터를 UI컴포넌트에서 불러와서 사용하는 방식으로 처리하여 위의 모든 문제를 해결하였으며 추후 사용시에도 개발자 간 의견 충돌이 없었던 경험이 있습니다.
    
- 타이포그래피를 최종적으로 리터럴 객체로 선언하고 사용하는 방식으로 해결하셨다고 하셨는데, 이런 방식이 성능에 미치는 영향이나 확장성에 대해서도 고려하셨는지 궁금합니다. 이 방식이 추후 확장되었을 때 성능상 문제나 관리 측면에서 예상되는 도전 과제가 있었는지 말씀해주시겠어요?
    
    위의 설명중 첫번째 방법이 확정성을 고려하여 만든것이였습니다. 하지만 타이포그래피는 단순 글꼴과 서체를 선언하고 사용하는 것이라는 정의에 따라서 디자이너와 개발자간의 약속된 타이포그래피 보다 더 많은 양의 타이포그래피를 생성하고 확장성을 가지는 것이 오히려 타이포그래피의 정의에 맞지 않다고 생각하여 이렇게 작업하였습니다.
    
- 그렇다면, 디자인 시스템 내에서 확장성을 고려한 다른 컴포넌트들도 있었을 텐데요. 다른 컴포넌트, 예를 들어 버튼이나 모달 같은 요소들에서는 확장성을 어떻게 처리하셨나요? 디자인 시스템의 원칙과 확장성 사이에서 어떻게 균형을 잡으셨는지 설명해주시겠어요?
    
    버튼과 같은 경우는 type별로 정의를 했습니다. warning, submit등의 타입이 있었고 size로는 크게 XL, L, M을 사용하였습니다. 그래서 type과 size그리고 onClick event를 props로 전달 받아 각각 다른 UI와 동작을 하도록 처리하였습니다.
    
    모달과 같은경우는 기본적인 UI가이드에서 추가되는 내용이 있으면 리액트 합성을 사용하여 처리하였습니다.
    
- 어떤 결과가 있었나요?
    
    우선 UI개발 업무 생산성이 개선되었습니다. 일관성있는 UI컴포넌트 개발이 가능했으며 디자인 QA 피드백 사항이 50%이상 감소하여 디자이너와 개발자의 리소스를 줄이는데 기여하였습니다. 또한, 리브랜딩과 같은 대규모 스타일 코드가 변경되는 상황에서도 간단하게 대응이 가능하도록 유지보수성 역시 상승시키는 효과가 있었습니다.
    

### Q) 유저들의 행동패턴 분석, 데이터 로깅을 통한 UX 개선

- 당신의 이력서를 보면 유저들의 행동 패턴을 분석하기 위해 Treasure Data를 도입했다고 되어 있는데, Treasure Data를 선택한 이유가 무엇인가요? 그리고 이 도구가 제공하는 주요 기능 중 어떤 기능이 특히 도움이 되었나요?
    
    저희는 서비스를 개발하면서 OKR방식의 업무 방식을 채택하였습니다. OKR방식으로 업무를 해 나아가면서 저흰 유저 행동패턴 데이터를 기반으로 새로운 서비스를 제공해야하는 상황이였습니다. 예로 들면 기획전 서비스를 제공할 때 유저들이 얼마나 스크롤을 내려보는지, 어떤 상품에 좋아요와 같은 관심사를 보이는지와 같은 데이터가 필요하였습니다. 이런 상황에서 저희는 웹과 모바일웹에서 데이터를 실시간으로 수집하고 저장하며 SQL기반 쿼리엔진을 제공하는 클라우드 기반 고객 데이터 플랫폼인 트레져데이터를 필요로 했습니다. 저는 트레져데이터를 사용하면서 간편하게 테이블을 생성하여 테스트할 수 있다는 점, 실시간으로 수집된 데이터를 SQL 쿼리 엔진을 통해 빠르게 유저의 행동패턴을 확인할 수 있다는 점에서 좋았습니다.
    
- Treasure Data를 사용하면서 유저 행동 데이터를 수집하고 분석하는 과정에서 겪었던 가장 큰 기술적 도전은 무엇이었나요? 그리고 그 도전을 어떻게 해결했는지 설명해 주세요.
    
    처음 트레져데이터를 활용해 유저 행동패턴을 분석하기위한 코드가 추가되었을 때 트래킹 코드로 인해 전반적인 코드의 양이 많아졌으며 하나의 함수에서 트래킹과 비지니스 로직을 함께 수행하면서 하나의 함수는 하나의 일만 잘해야한다 라는 컨벤션을 가지고 개발을 하는데 있어 문제가 있었고 당연히 코드를 파악하는데 들어가는 시간이 높아지니 유지보수성역시 좋지 않았습니다.
    
    이런 문제를 해결하기위해 tracking관련 폴더를 상위에 생성 후 해당 폴더 내 트레져데이터에 등록될 eventName별로 트래킹 함수를 분리하여 처리하였습니다. 이렇게 처리하여 필요한 트레킹 함수를 간단하게 import하여 방대한 트레킹 코드를 분리함으로 간결하고 유지보수성이 높으며 재사용 가능하도록 설계할 수 있었습니다.
    
- 트래킹 함수들을 분리해서 유지보수성과 재사용성을 높였다고 하셨는데, 이를 도입한 이후 팀 내에서 코드 품질이나 협업 방식에 어떤 변화가 있었나요? 또한, 그 과정에서 팀원들과의 의견 조율은 어떻게 이루어졌는지 궁금합니다.
    
    팀원과의 의견 조율은 초기에 있었습니다. 초기 방대한 양의 트레킹 코드를 분리하기위해 트레킹 폴더를 상위에 새성후 처리하잔 의견을 내고 트레킹 코드관련 작업은 따로 커밋을 하여 pr을 올리는 컨벤션을 잡고 작업하였습니다. 초기에 작업한 내용에 비해 코드는 간결하고 유지보수하는데 용이해지고 추후 해당 내용을 바탕으로 서로 코드리뷰를 하는 상황에서도 트레킹 코드를 따로 리뷰하여 서로의 리뷰하는데 소모되는 리소스를 감소하는 장점이 있었습니다.
    

### Q) 프로젝트 내 상태 관리 라이브러리 개선

- Redux-Saga에서 React-Query로 상태 관리 라이브러리를 변경한 이유는 무엇인가요? 그 과정에서 주로 어떤 문제를 해결하고자 했나요?
    
    상태관리 라이브러리를 redux, redux-saga를 사용하면서 클라이언트 상태와 서버 상태 관리의 분리가 모호하여 작업하는데 불편을 느꼈습니다. 여기서 클라이언트와, 서버 상태는 어디서 오너십을 가지고 핸들링을 하는지를 의미합니다. 예로들어 서버와 통신을 통해 데이터를 받아와야하는 데이터는 오너십이 서버에 있으니 서버 상태이고 클라이언트에서 오너십을 가지고 상태 데이터를 가지고 있는 것을 클라이언트 상태라고 했을 때 업무를 하면서 대부분의 상태관리는 서버 상태관리였습니다. 저는 이 2개의 상태관리를 분리하여 보다 유지보수성을 높히고 다른 개발자가 보더라도 빠르게 서비스에서 클라이언트와 서버의 상태관리에 대해 파악 하길 원해 변경하였습니다.
    
    또한, 간단한 api통신을 하더라도 action, action creator, reducer, saga등 너무 많은 보일러플레이트 코드가 추가되는 점 역시 불편함을 느껴 이런 문제를 해결하고자 react-query로 이전을 결정하고 작업하였습니다.
    
- React-Query로 상태 관리 라이브러리를 변경하면서 가장 어려웠던 부분은 무엇이었나요? 그 어려움을 어떻게 해결했는지도 함께 설명해 주세요.
    
    너무 방대한 상태관리 코드가 있는데 런타임 오류없이 어떻게 이전을 할지에 대해 고민이 되었습니다. 저는 이런 문제를 해결하기위해 처음부터 이전을 하려한게 아닌 작업을하면서 차차 이전해 나갔습니다. HOC로 작업된 컴퍼넌트 즉, connect를 사용한 컴포넌트에서는 훅기반으로 변경을 하였습니다. 이렇게 변경한 이유는 HOC기반으로 작업된 부분은 해당 데이터를 props로 전달받기에 props driling이 발생하고 있었고 이 과정에서 정확히 확인을 못해 데이터를 누락할까 염려되어 훅기반으로 우선적으로 작업하였습니다. 그후 react-query를 통해 데이터 통신을 하는 부분을 상위에 hooks라는 폴더를 생성 후 해당 폴더내 queries, mutation폴더를 생성하여 분리하였습니다. 그리고 도메인 별 서버 상태가 필요한 api통신코드를 작성후 해당 데이터가 필요한 컴포넌트에서 훅기반으로 작성된 redux코드를 제거후 해당 통신단 부분을 Import하여 사용하는 방식으로 변경하였습니다.
    
- React-Query로 이전하면서, 클라이언트와 서버 상태의 관리가 어떻게 개선되었나요? 그리고 Redux-Saga를 계속 사용하는 부분이 있었다면, 그 이유는 무엇인가요?
    
    클라이언트 상태관리는 redux라이브러리만 사용하는 부분으로 남겨놓았습니다. 이부분은 추후 zustand로 이전이 되었지만 바로 zustand까지 도입하기엔 시간적 문제가 있어 바로 작업하진 않았습니다. 이렇게 순수 redux로만 클라이언트 상태관리를 하도록 남겨놓았고 서버 상태는 react-query를 사용하는 hooks폴더로 자연스럽게 분리되었습니다. Redux-saga를 계속 사용하는 부분은 남아있었습니다. 애초에 한번에 프로젝트의 모든 서버상태를 받는 코드를 일괄 수정은 어렵다 판단하기도 하였고 해당 라이브러리로 이전하는데 필요한 공수를 가져가기도 회사에서 힘든 상황이라 특정 피쳐를 작업하면서 해당 피쳐 작업 한 부분에 만약 redux-saga를 통해 서버상태를 받는 코드가 있다면 해당 내용만 이전하면서 진행하는 방식으로 동료 개발자와 진행해서 Redux-Saga코드를 사용하는 부분은 남아있습니다.
    
- Redux-Saga와 React-Query가 함께 존재하는 상황에서, 두 라이브러리 간의 충돌이나 일관성 문제는 없었나요? 만약 있었다면, 어떻게 해결했는지 설명해 주세요.
    
    Redux-Saga와 React-Query가 함께 존재하는 상황에서, 두 라이브러리 간의 충돌이나 일관성 문제는 예상보다 크지 않았습니다. 우리는 상태 관리의 명확한 경계를 설정했습니다. Redux는 클라이언트 상태 관리에, React-Query는 서버 상태 관리에 집중하도록 철저히 분리했습니다. 이렇게 명확한 경계를 유지함으로써, 두 라이브러리 간의 책임 범위를 분명히 했습니다.
    
    또한, Redux-Saga에서 관리하던 일부 서버 상태를 React-Query로 전환하는 과정에서는 철저한 테스트와 단계적인 마이그레이션을 통해 일관성을 유지했습니다. 예를 들어, Redux-Saga에서 서버 데이터를 가져오는 로직을 React-Query로 옮길 때, 기존 로직과 새 로직이 공존하는 동안에도 동일한 API 응답을 받도록 설정하여 데이터 불일치나 중복 요청을 피했습니다.