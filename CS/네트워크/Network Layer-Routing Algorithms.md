

## 라우팅 알고리즘

라우팅 프로토콜은 라우팅 알고리즘이 필요로 하는 정보를 수집하는거다. 라우팅 프로토콜의 목적은 테이블을 만들어 패킷이 들어올 때 포워딩 테이블을 look up해서 패킷이 포워딩 될 수 있도록 하는거다.

![스크린샷 2024-07-16 오후 3.26.02.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/750d3410-3b46-49cb-be68-f86f60f30c7e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.26.02.png)

라우팅 알고리즘에서 네트워크를 그래프로 추출한다. 그래프로 네트워크의 라우터(N)와 그들 사이의 링크(E)를 모델링할 수 있다. 인터넷은 모든 링크의 코스트를 1로 하는데 경우에 따라 다르게 될 수 있다. 예로 링크에 bandwith, congestion, delay, 링크 사용 코스트에 따라 코스트를 다르게 할 수 있다. 결론적으로 라우팅 알고리즘의 목적은 source로 destionation까지 최소 비용의 경로를 발견한거다.

라우팅 알고리즘은 여러가지로 분류된다. 우선 global과 decentralized로 구분된다. 글로벌 알고리즘은 링크 스테이트라 부르며 각 라우터가 네트워크 전체 상태 정보를 가진다. 하지만 문제는 이 정보는 항상 연속적으로 가지고 있어야한다는 점이다.

decentralized 알고리즘인 distance vector 알고리즘은 아주 지역적인 정보만 알고있다. 이웃은 누구고 이웃까지 링크 코스트가 얼마인지에 대한 정보만 안다. 이 라우터는 이웃에게 어떤 목적지 서브넷까지가는 비용이 얼마인지 묻고 그 이웃은 또 그옆의 이웃에게 질문을 해 distance vector를 교환하는 방식이다. 이 정보가 점점 커지며 라우터가 모든 네트워크에 대한 정보를 알 수 있다.

또는 static 혹은 dynamic으로 분류를 할 수 있다. static은 링크 코스트를 고정적으로 한다. 링크 코스트가 변할 일이 없는 인터넷과 같은 경우 사용한다. 그리고 이런 static한 링크 코스트는 자주 사용될일이 없다. dynamic은 링크 코스트가 가변적이다. 특정 링크에 트래픽이 생겨 bandwith가 변하면 라우팅을 효율적으로 하기 위해 큰 bandwith의 링크로 보낼 때 이런 링크 코스트를 사용한다.

![스크린샷 2024-07-16 오후 3.41.21.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/daf34f5b-9030-47d8-b140-0fe0b319ff92/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.41.21.png)

글로벌 알고리즘에 대해 알아보면. Dijkstra’s알고리즘이 대표적인 링크 스테이트 알고리즘이다. 하나의 소스 노드로 네트워크의 모든 목적지에 대한 최단 경로를 발견한다. 네트워크에 호스트가 n개이면 가장 가까운 목적지로부터 n번의 iteration을 이행한다. 다익스트라 알고리즘은 위치 및 연결 정보를 입력 받아 로프가 시작되면 가장 가까운 노드를 N’로 옮겨 현재 최단 경로 정보와 비교하여 최단경로가 더 짧은 거리가 그 노드로 부터 있으면 정보를 갱신한다. 최종적으로 모든 노드가 N’로 옮겨지고 최단 경로가 파악된다.

![스크린샷 2024-07-17 오후 6.51.14.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/f0dea2d8-5ad7-480b-b36b-5a1f89d31dc0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.51.14.png)

다익스트라 알고리즘은 예이다. 숫자 옆 알파벳은 최단경로로 노드에 도달하기 이전 노드를 의미한다. 이전 노드를 추적해 가다 보면 최단 경로를 나타내는 트리가 그려진다. 다익스트라 알고리즘은 n번의 루트를 돌아 최악의 경우 n개가 N프라임에 전혀 들어있지 않아 n번의 비교를 해야하는 경우로 n(n-1)/2번의 비교를 수행해 O(N^2)의 시간 복잡도가 걸린다.

![스크린샷 2024-07-17 오후 6.54.52.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/443efb0a-d895-4318-a373-5edf9ec1aeb7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.54.52.png)

벨만 포드 알고리즘을 설명하겠다. 위 식은 x부터 y까지 최단 경로의 길이를 의미한다. 이 최단 경로는 x의 이웃노드로 y로 갈 때 다양한 경로가 있는데 모든 경로중 최단 거리가 있다. 최단 거리를 찾는 식이 빨간 색의 글이다. x로부터 y로 가는 최단 경로의 길이는 x에서 이웃인 v로 가는 비용에서 v에서 y로 가는 비용을 더한 것중 최소값이다.

![스크린샷 2024-07-17 오후 6.58.50.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/9a1ff898-3baa-4804-a506-a32eb83adc49/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.58.50.png)

벨만 포드 알고리즘의 예이다. u에서 z로 가는 최단 경로를 찾는다. u에서 이웃한 경로 길이 v,x,w,로 가는 최단 경로를 구하고 그 경로에서 z로 가는 길이를 더한 것중 미니멈 값이 du(Z)가 된다.

![스크린샷 2024-07-17 오후 7.08.08.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/5881e0b1-f23a-49a8-941a-60f9949578ec/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.08.08.png)

디스턴스 벡터 알고리즘은 벨만 포드 알고리즘을 이용한 것이다. 네트워크의 모든 목적지의 집합은 N일 때 Y는 네트워크 모든 목적지를 뜻한다. Dx(y)는 노드 x로 부터 y로 가는 최단 경로인데 노드x는 디스턴스 벡터 Dx를 유지 및 관리해야한다. 모든 목적지 Y에 대해 x로부터의 Dx(y)가 디스턴스 벡터다. x는 x로 부터 인접한 이웃으로 링크 코스트를 알고있고 이웃의 디스턴스 벡터와 자신의 디스턴스 벡터를 교환해 이웃의 정보까지도 알고있다. 디스턴스 벡터 알고리즘은 이웃의 디스턴스 벡터와 자신의 것을 교환해나가며 디스턴스 벡터 정보를 업데이트해 나간다. Dx(y)는 x가 경로 v로 가는 비용에서 Dv(y) 정보를 더해서 업데이트해 나가는데, Dv(Y)로 가는 정보를 계속해서 업데이트 하는것이 핵심이다.

각 라우터는 자신과 인접한 로컬 링크 코스트를 알고있고 이웃과 디스턴스 벡터를 교환한다. 이 교환 정보로 계속해서 자신의 디스턴스 벡터를 업데이트 할 수 있다. 만약 디스턴스 벡터의 변화가 생기면 이웃에게 자신의 변화된 정보를 알려야한다.

![스크린샷 2024-07-17 오후 7.09.57.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/b491d847-09ee-495a-a544-45a7cedcb9e4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.09.57.png)

각 노드들은 서로의 디스턴스 벡터를 교환하며 무한대였던 경로의 길이 정보를 재계산한다.

![스크린샷 2024-07-17 오후 7.12.05.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/c6409c04-8572-4975-81a3-b6fe41138d12/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.12.05.png)

링크 코스트의 변화는 어떻게 디스턴스 벡터에 반영될까 디스턴스 벡터가 줄어든 경우 만약 y에서 x로 가는 링크 코스트가 1로 줄어들면 y는 자신의 벡터를 재계산한다. 이 변경 정보를 이웃에게 알려준다. 따라서 정보를 받는 z는 위의 z에서 x로 가는 비용을 5에서 2로 재계산하여 다시 이 변경 정보를 이웃에게 알린다. 그러나 y는 z의 재계산 소식을 들었지만 그로 인해 본인의 벡터 정보의 변화가 없으니 어떠한 메세지도 z에 보내지 않는다.

그러나 링크 코스트가 들어난 안좋은 경우 만약 y에서 x가 4에서 60으로 늘어나면 y는 이웃 노드를 쳐다본다. 이때 z는 변경 전 x로 가는 거리를 5로 인식 했으므로 y는 z로 가는 비용 1에 z에서 x로 가는 비용 5를 더해 총6만에 x로 갈 수 있다고 생각된다. 해당 정보로 디스턴스 벡터를 업데이트 하면 z는 y로 가는 비용 1에 y에서 x로 가는 비용 5를 더해 6만에 x로 갈 수 있다고 생각하고 벡터를 수정한다. 위와 같은 과정을 44번씩 계속해야 51까지 비용이 늘어나고 z에서 x로 가는 50짜리 길로 경로를 바꿔 정확한 최단 경로를 얻는다. 따라서 count to infinity라 하여 계산이 과도하게 수행되는 문제가 일어난다. 이 문제를 해결하는 방법이 poisoned reverse인데, y가 x의 경로를 찾을 때 z를 통해 가는 길을 고려하지 않고 먼저 본인이 다이렉트로 x로 가는 길인 비용 60을 파악 후 z에 전달하는 것이다. 그럼 z는 y에서 x로 가는 비용이 60임을 먼저 인지하고 다이렉트로 50짜리 길을 선택할 수 있다. 그럼 y는 그 소식을 듣고 x까지의 경로를 51로 고칠 수 있다.

![스크린샷 2024-07-17 오후 7.26.56.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/c4c8f08d-c067-4579-a720-a64c00217f73/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.26.56.png)

링크 코스트를 고정적으로 혹을 가변적으로 사용할 수 있다. 링크 코스트가 링크를 지나가는 트래픽 양과 같으면(dynamic) 마치 진동하듯 루트가 계속 변경되는 route oscillations가 발생할 수 있다. 짧은 시간안에 루트 정보가 계속 변경하여 한 목적지로 내보내는 스트림에 속하는 데이터그램이 경로가 전부 변경되어 순서대로 도착하지 못하고 out of order하게 될 수 있는 문제가 발생한다. 또 링크 코스트가 계속 변경되어 라우팅 루프가 발생할 수 있다.

![스크린샷 2024-07-17 오후 7.29.50.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/794001a6-624e-4419-9a1d-c8b91e9f4ff0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.29.50.png)

네트워크 규모가 커지면 링크 스테이트는 처리할 양이 너무 커져 DV입장에서도 루프 발생 문제 등이 더욱 심해지게 된다. 따라서 실제로 네트워크를 autnomous systems(AS) 즉, 지역적으로 제한된, 한 기관에 집합 라우터의 집합으로 묶는다. 이 AS내에서 한 가지의 라우팅 프로토콜을 돌려서 이곳에 속한 서브넷 목적지에 대한 포워딩 테이블을 만든다. 이 안에서 실행되는 라우팅 프로토콜을 intra-AS라 부른다. AS끼리도 연결해야 하니 이를 gateway router로 연결한다.

![스크린샷 2024-07-17 오후 7.31.38.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/88d536e9-677c-4f72-97c9-d66cbe0ec73b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.31.38.png)

포워딩 테이블의 서브넷 목적지는 intra as subnet과 inter as subnet 즉, as안과 바깥으로 나눈다. intra에서는 인트라 라우팅 프로토콜을 통해 포워딩 테이블을 작성하지만 inter에 대해서 이뿐아니라 이에 더불어 inter as 프로토콜을 사용해 포워딩 테이블을 작성한다.

![스크린샷 2024-07-17 오후 7.33.07.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/450283f1-f90c-43d3-a40a-3471f9c41d99/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.33.07.png)

inter as와 intra as가 어떻게 협력할까? 위 이미지에서 as1의 입장에서 as2와 as3을 통해 도달할 수 있는 목적지가 무엇이 있는지 인지해야 한다. 이를 inter as라우팅 프로토콜을 통해서 인지할 수 있다. 게이트웨이를 통해 각 as에 어떤 서브넷 목적지가 있는지 전달하는 것이 inter as의 역할이다. 또한 타 as와 연결되어있는, 예로 as1의 1c와 1b는 외부 세계로 부터 어떤 서브넷이 있는지 내부 as에 소문을 내준다. as3에서 x에 갈 수 있다면 1c는 본인을 거쳐 as3에서 x에 갈 수 있다는 정보를 본인 as 내부에 전달한다. 이것이 inter as의 역할이고, 1d의 입장에서는 x에 보낼 것이 생긴다면 이 정보를 듣고 1c로 가는 길을 내부 테이블에서 파악한 후 내보낸다. 결국 1d는 다른 as에 속한 x로 가기 위한 인터페이스가 무엇인지 포워딩 테이블을 세팅할 수 있다.