

![스크린샷 2024-07-17 오후 9.29.52.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/670da48b-5f13-437e-86b9-0f2436888a47/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.29.52.png)

브로드캐스트란 한 소스가 말한 데이터를 네트워크 상의 모든 노드가 알아야 하는 것이고, 멀티 캐스트는 한 소스의 데이터를 네트워크의 복수의 노드에서 받는다. 그림에서 소스인 R1이 하나의 데이터에 대해 전체 노드에 대한 여러가지 복사본을 내보냄으로 소스와 가까운 노드, 그림에는 R2의 부담이 심화된다. 따라서 비효율적이다. 만약 네트워크 코어의 모든 라우터들이 브로드캐스트를 위한 루트 정보를 별도로 미리 알고 있다면 R1에서 복사를 하지 않고 가까운 라우터로 몇개의 데이터만 내보내도 각 라우터가 그 정보를 통해 데이터를 복사해서 정해진 경로로 내보내면 됨으로 훨씬 효율적이다. 그러나 소스는 이 데이터를 받는 recipient의 주소를 일일이 파악해야 하는데 이 과정이 매우 어렵다.

![스크린샷 2024-07-17 오후 9.34.12.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/001aa9a7-f86c-4624-9473-4df49bd933c2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.34.12.png)

그래서 멀티 혹은 브로드캐스팅을 위한 라우팅 프로토콜이 제안되었다. 만약 노드에 브로드캐스트 패킷이 들어오면 노드의 아웃풋 포트로 해당 패킷을 전부 내보내야한다. 이를 flooding이라 한다. 그런데 똑같은 패킷이 다시 들어오면 다시 보내는 루프가 생기는 브로드캐스트 스톰이 일어난다. 따라서 규칙에 의해 flooding을 컨트롤 해야한다. 그래프의 모든 노드를 지나면서 루프가 없는 트리인 spanning tree를 따라 브로드캐스팅이 전달되면 링크에 중복된 패킷이 왔다갔다 하는 일이 없게된다.

![스크린샷 2024-07-17 오후 9.37.14.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/02b0dbab-2e28-43c8-8ddc-bdf4269eed21/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.37.14.png)

멀티 캐스팅의 경우 라우터가 네트워크 topology를 알고, topology의 어느 곳에 목적지가 있는지 알아야 멀티캐스팅 포워딩 테이블을 작성할 수 있다. 모든 그룹 멤버가 하나의 트리를 사용하는 것을 shared tree라 한다. 각 소스에서 각 멀티캐스트 그룹 멤버로 가는 최단 경로 트리를 만들어 그 트리에 속한 곳으로 내보내야 한다. 이 트리를 source based tree라 한다.

![스크린샷 2024-07-17 오후 9.40.14.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/622562de-e22d-4358-802f-7475ffff1af3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.40.14.png)

grouped shared tree는 복잡성이 너무 높은데 이를 해결하기 위해 샌터를 루트로 하는 최단 경로 트리를 그리고, 센터는 네트워크 전체에 알려져 있으므로 라우터들은 센터 루트로 가는 최단 경로만 알고 있으면 된다.