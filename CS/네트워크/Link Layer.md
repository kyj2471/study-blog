---

![스크린샷 2024-07-17 오후 10.05.07.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/01caeb37-551d-4ad3-b0cc-27b91d19456b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.05.07.png)

`ARP`는 IP주소를 물리적 네트워크 주소인 `MAC주소`로 변환하는 프로토콜이다. 그리고 `MAC 주소`는 네트워크 인터페이스 카드인 NIC에 할당된 고유 식별자 이다.

지금까지 32비트의 IP주소를 가지고 표현했다. 네트워크 계층에서 이를 목적지에 표시해 포워딩 테이블을 작성한다. 실제로 노드에서 노드로 연결되는 링크를 건널 때는 어떤 프레임에 동봉해서 메세지를 보내야한다. IP계층에서 소스와 목적지는 본래 소스 호스트와 목적지 호스트가 아닌 링크의 양 끝에 있는 노드가 소스와 목적지가 된다. 링크를 건낼 때 동봉되는 프레임이 MAC 프레임이며 이 주소가 MAC 주소이다.

![스크린샷 2024-07-17 오후 10.08.21.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/3f4e328f-6efe-4073-b709-553559cf98d4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.08.21.png)

사진에서 각 호스트들은 네트워크에 붙는 물리적인 어댑터인 초록 막대기 부분을 가지고 있다. 어댑터에는 각각의 물리적인 MAC 주소가 할당된다. 이는 이들을 연결하는 스위치가 이더넷인지 와이파이인지에 따라 할당된다.

![스크린샷 2024-07-17 오후 10.13.07.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/a5e5d3ea-a60e-4154-94e6-67b5b306bdff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.13.07.png)

한 노드에서 다른 노드로 가기 위해 다음 홉으로 가는 물리적 링크를 실을 때 프레임 헤더의 필드의 어댑터의 MAC 주소를 적어 주는 IP주소에 MAC 주소 매핑이 필요하다는 것이다. 이 매핑 정보는 ARP 테이블에 저장되어 있다. 여기에 매핑과 더불어 매핑 정보의 유효시간을 적어둔 TTL 정보도 있다. 이렇게 일정 시간동안 유지가 되는 정보를 soft state라 한다.

![스크린샷 2024-07-17 오후 10.16.18.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/07193b1e-6d8d-43f2-a2f9-a76ada7cb3fe/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.16.18.png)

ARP 테이블은 ARP프로토콜에 의해 생성된다. a가 b로 무언가 보내고자 하면, 중간에 연결된 이더넷 스위치를 위해 이더넷 프레임에 자신과 b의 mac 주소를 실어줘야한다. 그러나 a가 b의 MAC주소를 모르니 a는 ARP 쿼리를 브로드캐스팅 하는데 쿼리에 b의 IP주소를 실어 보낸다. 브로드캐스팅 하면 네트워크의 모든 노드들이 받아 보게 되는데 b는 그 IP주소와 자신이 일치하니 a의 요청을 알아차리고 a에 ARP retrive하여 MAC주소를 보낸다.

ARP 테이블은 IP주소와 MAC주소를 20분간 캐싱한 것과 같다. 다른 관리자의 개입없이 노드가 직접 ARP 테이블을 셋팅할 수 있으니 즉시 시작 가능한 플러그인 플레이 방식이다.

![스크린샷 2024-07-17 오후 10.19.43.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/25708876-5cb1-451a-9ef1-0e93e6812984/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.19.43.png)

위의 A와 B 호스트는 라우터에 의해 연결되어있다. A는 B에게 메세지를 보내기 위해 목적지 B의 IP주소를 알고 있어야한다. A는 B로 메세지를 보내기 위해 first hop라우터로 보내야한다. 이 때 라우터 R로 무언가를 보내려면 라우터 R의 맥 주소를 알아야한다. a에서 b로 가기 위한 다음 홉은 R이라는 결정을 IP에서 이뤄진다. R의 MAC 주소는 ARP에 의해 알 수 있다. A는 B의 IP 주소를 알기 전 URL name을 알고있는데 DNS를 통해 URL과 해당 IP주소를 알 수 있다.

![스크린샷 2024-07-17 오후 10.25.17.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/c208f0b2-fa6f-4c04-9da7-ecc7ac85335c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.25.17.png)

A의 IP 계층에서 데이터그램을 만드는데 A와 목적지 B의 IP주소를 받는다.

![스크린샷 2024-07-17 오후 10.30.54.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/2f447f96-ebfd-4569-a41b-65a8987a2b69/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.30.54.png)

다음 홉 R로 메세지를 보내야 하니 웹 계층으로 내려오면 프레임을 만들 때 A의 MAC 주소와 R의 MAC주소를 적는다.

![스크린샷 2024-07-17 오후 10.31.13.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/31dad64a-d70a-4d96-8aae-b8ea263c95dc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.31.13.png)

물리 계층을 거치게 되며 이더넷 스위치로 통과해 R로 가게도니다. 라우터에서는 프레임에 있는 소스와 데스티네이션 MAC 주소를 보고 본인에게 잘 왔는지 확인하고 이 정보를 조회한다.

![스크린샷 2024-07-17 오후 10.32.20.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/79b054dc-ae84-404a-9e4f-ed99a66b893b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.32.20.png)

라우터는 MAC 계층 확인이 끝나면 IP계층으로 올려보내 목적지 IP주소를 보고 다음 홉을 결정하고 다음 홉을 위한 인터페이스인 어댑터로 보낸다.

![스크린샷 2024-07-17 오후 10.33.11.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/21430370-ed3a-4ded-b9f3-973b04af7513/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.33.11.png)

IP 데이터그램을 다시 MAC계층으로 내려뷰내면 다시 소스 주소에는 어댑터의 맥주소, 목적지 주소에는 B의 어댑터 맥 주소를 적는다.

![스크린샷 2024-07-17 오후 10.33.31.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/085b85fc-69f0-460f-a4a4-2960e69e4ef9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.33.31.png)

B의 물리적인 계층에 이를 밀어 넣고 B에 도착하면 B는 맥주소를 통해 본인에게 도착했는지 확인하고, IP계층으로 올려보내 본인에게 잘 왔는지 확인한다. 즉, IP주소는 목적지 호스트로 가기 위한 다음 홉이 누구인가를 결정하는 것이며, MAC주소는 다음 홉으로 가기위한 링크를 타야하는데 이 링크를 타기 위한 소스 데스티네이션 프레임을 만들어 내보내는것이다.

---

## 프로토콜 시나리오 총망라

![스크린샷 2024-07-17 오후 10.50.57.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ad79c095-c62e-4268-8fe9-c9d202ae92f5/728b7b93-54a9-47ab-9ded-3d0d325efcc9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-07-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.50.57.png)

노트북을 캠퍼스 네트워크에 가져와서 구글에 접속을 해보자. 학교 네트워크에 랩탑을 연결하고 브라우저를 띄우고 URL을 타이핑해 구글에 웹페이지가 띄워지는 과정이다.

1. 랩탑이 학교 네트워크에 접속하면 커뮤니케이션 준비가 되기 위해 ip주소를 로컬 네트웤에서 할당받아야 한다. 랩탑에서는 외부세계에 무언가를 내보내기 위해 내 ip주소, 첫 홉 라우터의 주소, DNS 서버 주소를 알아야 한다. 이 세가지를 알아내는 프로토콜이 DHCP 프로토콜이다.
2. 그렇기에 랩탑을 켜는 순간 plug-in-play로 자동적으로 네트워크 셋팅을 위해 DHCP 프로토콜이 실행된다.
3. DHCP는 쿼리 메세지를 만들어 내려보내고 UDP 세그먼트로 동봉되고 DHCP 메세지는 로컬 네트워크 모든 곳으로 브로드캐스팅 된다.
4. 이 메세지를 받은 모든 노드 중 DHCP 서버 프로세스를 갖는 노드만 관심을 가진다.
5. 따라서 그 라우터는 DHCP 메세지를 담은 프레임을 받아 demux시켜 라우터에 탑재된 DHCP 서버 프로세스까지 올라간다.
6. DHCP 서버에서는 ACK 메세지를 만들고 IP로 내려와 다시 ACK 메세지를 브로드캐스팅한다.
7. 그럼 다시 브로드캐스팅된 메세지를 모두가 받겠지만 쿼리를 보낸 랩탑만 그 메세지에 반응한다.
8. 다시 랩탑에서 ACK 메세지를 받아들이고 클라이언트 프로세스는 DHCP에서 알려주는 자신의 IP주소와 첫 홉 라우터의 IP 주소와 DNS 서버의 이름과 주소를 알게된다.
9. 사용자가 HTTP 요청을 보내려면 IP주소를 알아야 하는데 DNS 서버에 이를 물어야 한다. 랩탑의 DNS 계층에서는 IP 주소를 발견하기 위한 DNS쿼리 메세지를 만든다. 메세지가 UDP 세그먼트로 동봉되고 IP주소에 다시 동봉되는데 이때 데이터그램의 목적지는 DNS 서버의 IP주소가 들어간다.
10. 랩탑에서는 DNS 메세지를 내보내려면 첫 홉 라우터로 가야 하는데 이 주소를 모른다.
11. 그러므로 MAC 계층에서 DNS 메세지를 보내기 전 ARP 쿼리를 만들어 보냅니다. 그러면 첫 홉 라우터가 응답을 보내 이 라우터 MAC주소를 알 수 있고 DNS 쿼리를 보낼 수 있습니다.
12. 그럼 DNS 쿠러ㅣ 프레임이 첫 홉 라우터로 도착하고 라우터에서 MAC 프레임을 확인 후 뜯어내 IP계층에서 다음 홉이 어디로 가는지를 찾습니다. 이는 intra as 라우팅 프로토콜과 inter as 라우팅 프로토콜의 협력으로 라우팅 테이블을 만들어 찾아냅니다.
13. intra 라우팅 프로토콜을 활용해 목적지 DNS 서버까지 배라됩니다. 서버에서 demux를 통해 DNS 서버까지 배달됩니다.
14. DNS서버에서 그 URL에 대한 IP주소를 작성해 랩탑으로 응답을 보냅니다.
15. 웹 서버로 HTTP 요청을 보낼 준비가 되었습니다. HTTP는 TCP 위에서 동작합니다. TCP는 웹 서버와 커넥션 셋업을 해야합니다. 따라서 handshacking을 위해 웹 서버에 syn메세지를 보냅니다.
16. 웹서버의 TCP 계층에서 싱크 메세지를 받으면 TCP에서 싱크 ACK 메세지를 만들어 응답합니다.
17. 랩탑에서 이를 다시 demux해 TCP 커넥션을 완성하고 3-way handshaking을 위해 다시 ACK를 보내는데 이때 ACK메세지에 유저 메세지를 실어 보낼 수 있습니다. 이 때 HTTP 요청을 합께 보냅니다.
18. 랩탑의 ip계층에서 데이터그램에는 구글 네트워크 웹서버의 목적지 주소가 적혀 있다. ip계층에서 목적지 주소를 보고 다음 홉을 결정한다. 다음 홉은 첫 홉 라우터이다. 다음 홉에 가기 위해서는 소스 주소에 랩탑의 맥주소와 목적지는 첫 홉 라우터의 맥 주소가 적혀 이더넷 프레임이 만들어진다.
19. 매세지가 라우터에 도착하면 라우터는 라우팅 테이블을 보고 메세지를 다음 홉 라우터로 보내는데 이때 메세지를 프레임에 실어 보낸다. 이때 역시 각 라우터의 맥 주소를 프레임에 실어 보낸다.
20. 랩탑에서 첫 홉 라우터로 보낼 때나, 홉에서 홉으로 메세지를 보낼 때 DNS쿼리를 보낼 때 ARP 테이블에 이미 이 정보가 캐싱이 이전에 되어 있었으므로 ARP 쿼리 없이 바로 전달이 가능하다.
21. ap세지를 웹 서버가 받으면 계속 올려보내다가 ip 계층에서 ip 목적지 주소가 본인인 것을 확인하고 TCP 계층으로 올려 보낸다. TCP는 소켓을 통해 HTTP로 올려 보낸다.
22. HTTP에서는 HTTP response를 만들어 다시 랩탑으로 보냅니다.
23. 랩탑에서 demux를 끝내면 브라우저에서 최종적으로 구글이 노출됩니다.