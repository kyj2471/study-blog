---

우선 예전이지만 일을 하다 겪었던 경험을 공유하겠다.

```jsx
let a = 10
let b = a
let address = { location:"서울특별시", detail:"1XX동 XXX호"}
let newAddress = address

b = 20
newAddress.location = "대구광역시"

console.log(a === b) // false
console.log(address === newAddress) // true
```

`console.log(a === b)` 의 결과는 누구나 쉽게 납득을 할 수있으나 두번째의 경우는 의아할 수 있다. 실제 현업에서 주소록관련 컴퍼넌트를 제작하면서 겪었던 경험이 있다. 기존 address를 newAddress로 수정하면서 address와 newAddress가 다른 경우만 해당 데이터 변경을 위한 api요청을 시도 하려했으나 비교시 일치한다는 결과가 출력되어 api요청을 하지 않았던 적이 있었다

분명 코드상 `newAddress객체의 프로퍼티 값만 변경하였는데 원본객체마저 영향을 받았다.` 그 원인에 대해 아래 내용을 확인하면 알 수 있었다.

### 데이터 할당

위의 상황에서 자바스크립트가 어떻게 데이터 할당을 하는지 확인하겠습니다.

|변수 영역|주소|1001|1002|1003|1004|
|---|---|---|---|---|---|
|변수 영역|데이터|이름: a||||
|값:@5001|이름:b|||||
|값:@5001|이름:address|||||
|값:@5002|이름:newAddress|||||
|값:@5002||||||
|데이터 영역|주소|5001|5002|5003|5004|
|데이터 영역|데이터|10|@7103 ~ ?|“서울 특별시”|"1XX동 XXX호"|
|객체 @5002의 변수영역|주소|7103|7104|||
|객체 @5002의 변수영역|데이터|이름:location||||
|값: @5003|이름: detail|||||
|값: @5004||||||

기본형 데이터, 참조형 데이터 모두 복사시 같은 주소를 봅니다. 여기서 `기본형과 참조형의 차이는 참조형은 객체 프로퍼티 영역이 따로 존재한다는 점`입니다. 이제 문제의 상황인 복사한 변수에 값을 재할당 하려하는 경우 어떤 일이 생기는지 확인하면 아래와 같습니다.

|변수 영역|주소|1001|1002|1003|1004|||
|---|---|---|---|---|---|---|---|
|변수 영역|데이터|이름: a||||||
|값:@5001|이름:b|||||||
|값:@5001 → @5006|이름:address|||||||
|값:@5002|이름:newAddress|||||||
|값:@5002||||||||
|데이터 영역|주소|5001|5002|5003|5004|5005|5006|
|데이터 영역|데이터|10|@7103 ~ ?|“서울 특별시”|"1XX동 XXX호"|“대구 광역시”|20|
|객체 @5002의 변수영역|주소|7103|7104|||||
|객체 @5002의 변수영역|데이터|이름:location||||||
|값: @5003 → @5005|이름: detail|||||||
|값: @5004||||||||

_**변수 a와 b는 서로 다른 주소를 바라보게되었고**_ 이로 인해 `console.log(a === b)` 가 false가 됩니다. 반면 address와 newAddress는 여전히 같은 객체를 바라보고있기에 위와 같은 문제가 발생하였습니다.

이로인해 해당 문제는 기본형은 주솟값을 복사하는 과정이 한번, 참조형은 한단계 더 거쳐 복사하기에 문제가 생긴다는것을 알았습니다.

## 불변객체

결론적으로 위와 같이 전달받은 객체에 변경을 가해도 원본 객체는 변하지 말아야하는경우의 문제 해결을 위해선 불변객체가 필요합니다. 여기서 주의 할 점은 `참조형 데이터의 가변성은 내부 프로퍼티를 변경할 때 성립 한다는 점입니다.` 즉, 새로운 객체를 return하면 기본형 데이터 타입과 마찬가지로 기존의 데이터는 변하지 않습니다.

이제 객체를 다시 복사하는 과정에서 얕은 복사, 깊은 복사에 대해 알아보면

**얕은 복사**

- 바로 아래 단계의 값만을 복사

**깊은 복사**

- 그 내부 모든 값들을 전부 복사

말 뜻에서 알 수 있듯 중첩객체에서 객체 내부의 프로퍼티의 값을 한단계만 복사하면 얕은 복사가 될 것입니다. 그렇다면 그 프로퍼티에 프로퍼티가 있는 중첩객체인 상황에서는 다시 제일 하위의 프로퍼티의 값만 변경된다면 위의 문제가 반복될 것입니다. 그렇기에 참조형 데이터 복사를 할 땐 깊은 복사를 하여 원본 객체에 영향을 주지 않도록 불변 객체를 생성해야합니다.

이런 문제를 해결 하기 위해 immutable.js, baoba.js, immer.js등의 라이브러리를 흔히 사용합니다. 아래에선 간단하게 위의 문제를 해결하기 위해 깊은 복사를 통해 해결해 보겠습니다.

```jsx
let a = 10
let b = a
let address = { location: "서울특별시", detail: "1XX동 XXX호" }
let newAddress = JSON.parse(JSON.stringify(address))

b = 20
newAddress.location = "대구광역시"

console.log(a === b) // false
console.log(address === newAddress) // false

```

실제로 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON객체로 변경하면 문제없이 동작합니.

# undefined vs null

js를 사용해 개발을 할 때 `없음` 을 표현할 때 둘중 어떤 기본형 타입을 사용해야할까? 둘의 차이로 보면 undefined는 null처럼 개발자가 직접 지정할 수도 있지만 반대로 자바스크립트 엔진이 값을 `대입하지 않은 변수, 객체 내부 존재하지 않는 프로퍼티 접근, return 문이 없는 함수의 실행 결과` 등 자동으로 부여한다.

```jsx
let a;
console.log(a) // undefined

let arr1 = []
arr1.length = 2
console.log(arr1) // [emplty x 2]

let arr2 = [undefined, undefined]
console.log(arr2) // [undefined, undefined]
```

첫번째 a 식별자를 확인해 보면 값을 대입하지 않는 경우에 대입했기에 undefined가 출력이 된다.

arr1, arr2는 서로 다른 결과가 출력되었다. 이 결과를 배열도 결국 객체다라고 생각하면 쉽다. 배열이 무조건 length의 프로퍼티 만큼의 공간에 인덱스를 이름으로 정하고 동작하는게 아닌 객체와 마찬가지로 값을 할당 해야 공간을 확보하고 index값을 이름으로 정하며 데이터 주솟값을 지정하는 동작을 합니다. 결론적으로 `값을 지정하지 않으면 존재하지 않은 프로퍼티 이며 undefined는 그 자체로 값입니다.`

그렇기에 일반적으로 비어있다를 명시할 땐 undefined를 할당하지 않고 null을 할당해 사용하면됩니다.