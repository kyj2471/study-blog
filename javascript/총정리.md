

# 총정리

---

# 데이터 타입

### 불변성에대해 설명해주세요?

기본형 데이터는 흔히 불변성을 가지고있다라고 말하고있습니다. var a = 1이라고 하고 a = 2라고 할때 변수영역에서 값이 바라보는 데이터 주솟값이 변경됩니다. 결론적으로 변경은 새로 만드는 동작을 통해만 이뤄집니다. 이것이 불변값의 성질입니다.

여기서 참조형 데이터는 그럼 가변값입니다~라고 하면 사실 그것또 아닙니다. 참조형 데이터가 가변값이려면 참조형 데이터자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 떄만 입니다.

여기서 문제가 프러퍼티가 변경되었을 때 문제로 사본 객체가 변경될 때 원본 객체도 함께 변한다는 문제가 있습니다. 이러한 문제로 불변객체에 대한 관심이 많아지고 immutable.js, baobab.js와 같은 라이브러리가 있었습니다. 하지만 간단하게 사용하려면 객체를 JSON문법으로 표현된 문자열로 전환하고 다시 JSON객체로 바꿈됩니다.

---

# 실행 컨텍스트

### 실행 컨텍스는 뭔가요?

실행할 코드에 제공할 환경 정보를 모아놓은 객체입니다.

### 자바스크립트에서 호이스팅이 무엇인가요?

컨텍스트가 실행될 때 식별자 정보를 가지고있는 것 입니다. 자세히 설명하면 실행컨텍스트(실행할 코드에 제공할 환경 정보들을 모아놓은 객체) 즉, 컨텍스트가 실행이될때 lexical, variable환경, thisbinding에대한 정보가 있습니다. 여기서 렉시컬환경에서 environmentRecord정보는 컨텍스트가 선언될 당시에 식별자 정보를 저장합니다. 컨텍스트가 실행될 때가아닌 선언될 때 식별자 정보를 알고있는 겁니다. 이렇게 미리 식별자 정보를 가지고있다는 것을 호이스팅이라고 합니다.

### 함수 선언문 vs 함수 표현식의 차이에 대해 말해주시고 뭘 쓰실건지도 말해주세요

함수 표현식을 사용합니다. 호이스팅 당시에 함수 선언문은 함수 자체가 호이스팅이되고 함수 표현식에서는 식별자 데이터만 호이스팅이 됩니다. 이로인해서 여러 개발자가 일하는 상황에서 생길 예상하지 못할수도있는 상황을 미연에 방지할것입니다.

### 스코프체인에 대해 설명해주세요

우선 식별자의 유효범위를 스코프라고합니다. 이렇게 스코프를 안에서 부터 바깥으로 차례로 검색해나가는 것을 스코프체인이라 합니다. 원리는 우리는 실행컨텍스트에서 lexical환경에서 outerEnvironmentReference에 대한 정보를 가지고 있습니다. 내부 함수 렉시컬환경에서 outerEnvironmentReference는 외부함수의 렉시컬환경을 참조합니다. 이때 outerEnvironmentReference에는 가장 가까운 컨텍스트의 렉시컬 환경만 참조함으로 가까운 요소부터 차례대로 접근합니다. 이런식으로 식별자의 유효범위를 안에 밖으로 차례로 검색해 나가는것을 스코프체인이라 합니다.

---

# THIS / 콜백함수

## this의 값은 어떻게 결정될까요?

실행컨텍스트가 생성될때 결정됩니다. 그리고 실행컨텍스트는 함수 호출할때 생성되니 this는 함수를 호출할 때 결정됩니다.

## 명시적 바인딩에는 어떤 방법이 있나요?

call, apply, bind메서드를 사용해서 this를 명시적으로 지정할 수 있습니다. call, apply는 즉시 함수를 실행하고 bind는 call과 비슷하지만 즉시 호출하지 않고 넘겨받은 this및 인수들을 바탕으로 새로운 함수를 반환합니다.

## 화살표 함수에서 this는 어떻게 될까요?

화살표함수는 실행컨텍스트를 생성할 때 thisbind과정이 빠지게되어(함수로 호출시 this가 전역객페를 바라보는 문제) 상위 스코프의 this를 활용합니다.

## 생성자 함수를 사용할 때 this동작방식이 어찌될까요?

생성자 함수라는게 공통된 성질을 지니는 객체들을 생성할 때 사용합니다. 생성자 함수를 호출하면 생성자함수에 prototype의 프로퍼티들을 참조하는 **proto** 라는 프로퍼티가있는 객체(인스턴스)를 만들고 공통 속성 및 개성을 해당 this에 부여합니다.

## this 사용시 주의할점

this가 호출한 컨텍스트에 따라 결정되다보니 함수를 호출했을 때 this가 어떤값을 가르키고있는지 주의해야합니다.

## 콜백함수와 this

일단 기본적으로 콜백함수도 함수입니다. 함수에서 this는 전역객체를 참조합니다. 하지만 제어권을 넘겨받을 코드에 콜백함수에 this가 될 대상을 지정하면 그대상을 참조합니다.

## 콜백함수에서 this를 지정하는법

여러방법이 있습니다. 함수 내부에 self변수에 this를 담고 익명함수를 호출과 동시에 반환, this를 사용하지 않고 직접 접근해도됨(재사용 불가능) 그리고 bind메서드를 활용도 가능

---

# 클로저

### 클로져란 무엇이고 왜 중요합니까?

클로져는 외부함수의 실행컨텍스트가 종료된 이후에도 외부함수 렉시컬 환경이 내부함수에 의해 참조됨으로 가비지 컬렉팅이 되지 않는 현상. 이로인해 외부 변수에 접근할 수 있으며, 데이터를 은닉하고 정보를 보호할 수있습니다(return한 값만에 접근이 가능해서).

## 클로져가 어떻게 생성되나요?

외부함수에 정의된 내장함수가 외부로 retur되면서 생성됩니다. 이러면 내장함수가 외부함수의 렉시컬환경을 참조하면서 생성됩니다.

## 클로저 어떤 용도로 씁니까?

정보 은닉이라 합니다. 프라이빗 변수와 함수를 구현할 때 사용합니다. 외부에 노출되면 안되는 변수나 함수를 클로저 내부에서 정의하고 접근해서 사용합니다. 그러면 노출되면 안되는 변수는 유지되고 외부에서 참조할수있는 값은 해당 함수에서 return한 값만을 확인할 수있습니다.

## 클로저와 메모리 관리

클로저는 외부함수의 변수를 참조합니다. 이 변수는 javascript의 가비지컬렉팅때문에 참조카운팅이 0이되지 않으면 계속 메모리에 유지됩니다. 이 상황에서 해당 변수가 더이상 필요하지 않는데 계속해서 참조를해 참조카운팅이 발생해서 가비지컬렉팅 대상이 되지 않는 경우는 메모리 누수가됩니다. 그러니 메모리 누수가 발생하지 않도록 하기위해 필요성이 사라진 시점에 식별자에 null을 할당해서 참조를 끊어주면됩니다.

## 클로저와 스코프 체인의 관계

클로저는 애초에 내장함수에서 외부함수의 식별자 정보에 접근이 가능하기에 벌어지는 현상입니다. 그리고 이는 내장 함수의 실행컨텍스트가 발생할 때 내장 함수 렉시컬 환경의 outerEnvironmentReference에서 외부함수 렉시컬 환경 즉 식별자 정보에 접근을 할 수있기 때문에 가능한 현상입니다.

---

# 프로토타입

## 프로토타입이 뭔가요?

프로토타입은 객체지향 프로그래밍에서 상속을 구현하는데 사용되는 메커니즘입니다. 자세히 알아보면 javascript는 함수에 객체인 prototype프로퍼티를 생성해놓는데 이 함수가 생성자 함수로 사용되여 인스턴스를 생성하면 그 인스턴스에는 프로토라는 객체가 생성되는데 이 프로토는 생성자 함수의 프로토타입 프로퍼티를 참조합니다.

이런 이유로 생성자 함수 프로토타입에 메서드나 프로퍼티가 있으면 인스턴스에서도 해당 프로토타입에 접근이 가능해 자기것처럼 사용이 가능합니다.

## 프로토타입 체인과 체이닝에 대해 알고계신가요?

A1)어떤 데이터의 프로토 프로퍼티 내부에 다시 프로토 프로퍼티가 연쇄적으로 이어진걸 프로토타입 체인이라 합니다. 이 체인을 따라 검색하는걸 프로토타입 체이닝이라 합니다.

Object의 인스턴스를 확인해보면(프로토) hasOwnProperty, toLocaleString과 같은 메서드가 보입니다. 배열프로토에는 pop,push, concat등이 있습니다. 하지만 이 프로토안에는 프로토가 또 있습니다. 이 프로토에는 객체의 프로토와 동일한 메서드와 프로퍼티가 정의되어있습니다. 이유는 프로토타입 객체가 객체기 때문입니다리~ 결론적으로 모든 객체의 프로토에는 Obejct.prototype이 연결됩니다.

A2) 프로토타입 체인은 객체가 프로퍼티나 메서드를 찾을 때 사용되는 메커니즘으로, 객체의 **`__proto__`** 속성을 따라 부모 객체로 이동하여 프로퍼티나 메서드를 검색합니다.

## prototype과 proto속성의 차이는 뭐가 있나요?

프로토타입은 함수 객체만 가지고있고 이 함수를 생성자 함수를 통해 인스턴스를 생성할 때 이 인스턴스에는 프로토라는 프로토타입을 참조하는 객체를 생성합니다. 결론적으로 프로토는 모든 객체가 가지고있고 프로토타입은 함수 객체만 가지고있습니다.

## 프로토타입 체인으로 상속된 메서드를 오버라이딩 가능합니까?

자바스크립트 엔진이 메서드를 찾을 때는 가장 가까운 대상인 자신의 프로퍼티를 검색하고 없으면 다음 프로토로 접근하는 순서로 검색합니다. 그렇기에 하위 객체에서 동일한 이름의 메서드를 정의하면 상위 객체에서 상속된 메서드를 오버라이딩 할 수있습니다.

## 프로토타입 체인이 중단되는 경우가 있나요?

Object.create(null) 즉 null을 프로토타입으로 가지는 객체는 프로토타입 체인이 중단됩니다. 이러면 인스턴스에는 프로토 프로퍼티가 없는 객체를 할당합니다. 이런 방식으로 만든건 일반 데이터에 존재하는 내장 메서드 및 프로퍼티가 제거되서 기본적인 기능이 제거된 대신 객체의 무게를 가볍게 하여 성능향상을 하기 위함입니다.

---

## 자바스크립트의 스코프 체인과 프로토타입 체인의 차이점은 무엇인가요?

스코프체인은 함수의 렉시컬 스코프에 의해 결정이되고 함수가 정의된 위치에 의해서 결정됩니다. 반면 프로토타입체인은 객체의 프로토타입 속성에 의해 결정되고 객체의 상속 구조에 따라 결정이됩니다.
사용할때도 스코프체인은 변수, 함수의 스코프를 결정하고 클로저 기능을 지원합니다. 프로토타입 체인은 객체 상속이 가능하게 구현해주고 상속된 프로퍼티나 메서드에 접근할 수있게해줍니다.

스코프체인은 변수 함수를 검색하는데 사용하고 프로토타입 체인은 객체의 프로토 속성을따라 부모 객체로 이동하면서 프로퍼티를 검색하는 것 입니다.

---

# 프로젝트

## 적용하게된 계기

## 
