
---

### Q) `클로저(Closure)`란 무엇인가요? `클로저`를 활용하는 예시를 설명해주세요.

- 답변
    
    클로저는 실행컨텍스트가 종료된 외부함수내 식별자 정보를 참조하는 내부함수입니다. 동작 원리는 내부 함수가 해당 식별자를 참조함으로 참조 카운트가 0이 아니여서 외부함수의 실행컨텍스트가 종료되었음에도 해당 식별자 정보가 가비지컬렉팅 대상이 되지 않아서 발생합니다. 이를 통해서 변수의 은닉, 상태유지가 가능하다.
    

### Q) `이벤트 버블링(Event Bubbling)`과 `이벤트 캡처링(Event Capturing)`의 차이점을 설명하고, 이를 어떻게 제어할 수 있는지 알려주세요.

- 답변
    
    이벤트 버블링은 이벤트가 발생한 요소에서 시작해서 점차 상위 DOM요소로 전파되는 과정을 말한다. 반대로 이벤트 캡처링은 최상위 DOM요소에서 시작해서 이벤트가 발생한 요소로 전파되는 과정이다. 기본적으로 이벤트는 캡처링 단계에서 시작해서 버블링 단계에서 끝납니다. 제어 방법은 addEventListener메서드를 사용해 이벤트 핸들러를 추가할 때 세번째 인자로 true를 전달하면 이벤트 캡처링단계에서 핸들러가 호출되고 false를 전달하면 이벤트 버블링 단계에서 호출된다. 또한 stopPropagation 메서드를 사용해서 이벤트가 더이상 상위 요소로 가는 것을 막을 수 있다.
    

### Q)**`this` 키워드는 JavaScript에서 어떻게 동작하나요? `this`가 다른 컨텍스트에서 어떻게 다르게 작동하는지 설명해주세요.**

- 답변
    
    this는 실행컨텍스트가 생성될 때 결정된다. 실행컨텍스트는 함수가 호출될 때 생성된다. 즉, this는 함수가 호출될 때 결정되며 이떄 this는 해당 함수가 속한 컨텍스트를 가리키게 된다. this는 함수가 어떻게 호출되냐에 따라 동작방식이 다르다. this가 함수로 실행된 경우 전역객체를 바라보게된다. 그리고 특정 객체의 메서드로서 실행된 경우 this는 해당 객체를 바라보게된다. 생성자 함수에서 this는 새로 생성된 객체 인스턴스를 바라보게된다.
    
    이런 상황에서 함수로 실행될 때 this가 개발자에게 혼돈을 피하기 위해 call, apply, bind와 같은 메서드를 통해 this에 바인딩 될 객체를 명시하여 사용할 수 있다. 최근 화살표 함수의 추가로 화살표함수는 자신의 this가 아닌 상위 컨텍스트의 this를 상속받는다.

### Q) `var`과 `let, const`의 차이점을 말씀해주시고 주의사항도 말해주세요

- 답변
    
    3가지의 차이점이 있습니다. 스코프, 호이스팅, 재선언과 재할당입니다.
    
    1. **스코프(Scope) 차이점**:
        - `var`는 **함수 스코프**를 가집니다. 즉, 함수 내에서 선언된 `var` 변수는 그 함수 전체에서 유효합니다. 반면, `for`, `if` 등의 블록 안에서 선언해도 블록을 벗어나면 접근이 가능합니다.
        - `let`과 `const`는 **블록 스코프**를 가집니다. `{}`로 감싸진 블록 안에서만 유효하며, 블록 밖에서는 접근할 수 없습니다. 이로 인해 `let`과 `const`는 보다 안전한 변수 선언 방식입니다.
    2. **호이스팅(Hoisting)**:
        - `var`는 선언과 초기화가 호이스팅됩니다. 이 말은, 변수를 선언하기 전에 해당 변수에 접근할 수 있지만, 이때의 값은 `undefined`입니다. 즉, 변수 선언이 코드 상단으로 끌어올려지지만 초기화는 나중에 이루어집니다.
        - `let`과 `const`도 선언은 호이스팅되지만, 초기화는 호이스팅되지 않습니다. 그리고 `Temporal Dead Zone`(TDZ)이라 불리는 구간이 발생하여, 변수 선언 전에 해당 변수에 접근하려 하면 **참조 에러(ReferenceError)**가 발생합니다.
    3. **재선언 및 재할당**:
        - `var`는 **재선언**과 **재할당**이 모두 가능합니다. 이는 같은 변수 이름을 사용해 여러 번 선언하는 실수를 초래할 수 있어 예기치 못한 버그를 유발할 수 있습니다.
        - `let`은 **재할당**은 가능하지만 **재선언**은 불가능합니다. 이는 변수가 중복 선언되는 문제를 방지할 수 있습니다.
        - `const`는 **재선언**과 **재할당**이 모두 불가능합니다. 한 번 선언된 후에는 값을 변경할 수 없으며, 상수를 선언할 때 사용됩니다. 하지만 `const`로 선언된 객체의 내부 프로퍼티는 변경할 수 있습니다. 이는 변수 자체는 상수지만, 객체의 속성 변경이 가능하다는 특성을 가지고 있습니다.